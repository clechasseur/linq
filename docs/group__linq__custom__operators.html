<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coveo::linq: Implementing custom LINQ operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coveo::linq
   </div>
   <div id="projectbrief">Implementation of .NET-like LINQ operators in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Implementing custom LINQ operators<div class="ingroups"><a class="el" href="group__linq.html">LINQ expressions</a> &raquo; <a class="el" href="group__linq__operators.html">LINQ operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>How to design and implement your own LINQ operators.  
<a href="#details">More...</a></p>
<p>One of the features of the <code>coveo::linq</code> library is that LINQ operators are implemented as <em>function objects</em> to be applied to a sequence, instead of member functions (of <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code> for instance.) This makes it easy to extend the library by implementing new operators.</p>
<p>To make it easy to apply LINQ operators, the library defines, for each operator, a corresponding function that simply returns the <em>function object</em>. Then, <code><a class="el" href="group__linq__chaining.html#gaf38ff23c8bdf9a47b55e516dd378194e" title="Applies LINQ operators and allows chaining.">coveo::linq::operator|()</a></code> is used to <em>apply</em> the LINQ operator to a sequence. What this means internally is that <code><a class="el" href="group__linq__chaining.html#gaf38ff23c8bdf9a47b55e516dd378194e" title="Applies LINQ operators and allows chaining.">operator|()</a></code> calls the operator's function object's <code>operator()()</code> member function, passing it the sequence to apply it to. The operator's function object must then perform its work and return either a new sequence or perhaps a single value (for a terminal operator).</p>
<p>Here is a real-world example of this. Let's say we wanted to implement a new LINQ operator named <code>step</code> that steps through a sequence by specific increments. First, we declare the shell of our function object that implements the operator, along with an <code>operator()()</code> so that the operator can be applied to a sequence:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t step_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t step) : step_(step) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) {</div><div class="line">        <span class="comment">// TODO</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note that the sequence's type is not specified in the class template itself - when the operator's function object will be created, we won't know the type of sequence yet. Instead, it is specified as a template argument to <code>operator()()</code> itself. Also note that the function object's constructor must receive all parameters it needs to work (except for the sequence of course). In our case, we receive the number of steps to use for each invocation.</p>
<p>Because our operator must step through elements of the sequence it is applied to, it needs to return a new sequence. Furthermore, that sequence must wrap the source sequence to be able to iterate its elements. One way to do this without implementing complex sequence logic is by using <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code>. This sequence wrapper's only requirement is that we implement a <em>next delegate</em>: a function that, when called, returns a pointer to the next element in the sequence, or <code>nullptr</code> when done. <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code> is used extensively in the <code>coveo::linq</code> library to implement LINQ operators.</p>
<p>Let's add a skeleton for a next delegate to our example:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl(Seq&amp;&amp; seq) {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t step_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t step) : step_(step) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;typename coveo::seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq));</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note the use of <code><a class="el" href="structcoveo_1_1seq__traits.html" title="Traits class for a sequence.">coveo::seq_traits</a></code> to produce a sequence of the same type of elements as the source sequence. Along with <code><a class="el" href="structcoveo_1_1seq__element__traits.html" title="Traits class for elements in a sequence.">coveo::seq_element_traits</a></code>, these can be used to simplify detection of sequence types in LINQ operator implementations. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 8 2019 01:58:09 for coveo::linq by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
