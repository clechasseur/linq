<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coveo::linq: Implementing custom LINQ operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coveo::linq
   </div>
   <div id="projectbrief">Implementation of .NET-like LINQ operators in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Implementing custom LINQ operators<div class="ingroups"><a class="el" href="group__linq.html">LINQ expressions</a> &raquo; <a class="el" href="group__linq__operators.html">LINQ operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>How to design and implement your own LINQ operators.  
<a href="#details">More...</a></p>
<p>One of the features of the <code>coveo::linq</code> library is that LINQ operators are implemented as <em>function objects</em> to be applied to a sequence, instead of member functions (of <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code> for instance.) This makes it easy to extend the library by implementing new operators.</p>
<p>To make it easy to apply LINQ operators, the library defines, for each operator, a corresponding function that simply returns the <em>function object</em>. Then, <code><a class="el" href="group__linq__chaining.html#gaf38ff23c8bdf9a47b55e516dd378194e" title="Applies LINQ operators and allows chaining.">coveo::linq::operator|()</a></code> is used to <em>apply</em> the LINQ operator to a sequence. What this means internally is that <code><a class="el" href="group__linq__chaining.html#gaf38ff23c8bdf9a47b55e516dd378194e" title="Applies LINQ operators and allows chaining.">operator|()</a></code> calls the operator's function object's <code>operator()()</code> member function, passing it the sequence to apply it to. The operator's function object must then perform its work and return either a new sequence or perhaps a single value (for a terminal operator).</p>
<p>Here is a real-world example of this. Let's say we wanted to implement a new LINQ operator named <code>step</code> that steps through a sequence by specific increments. First, we declare the shell of our function object that implements the operator, along with an <code>operator()()</code> so that the operator can be applied to a sequence:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) {</div><div class="line">        <span class="comment">// TODO</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note that the sequence's type is not specified in the class template itself - when the operator's function object will be created, we won't know the type of sequence yet. Instead, it is specified as a template argument to <code>operator()()</code> itself. Also note that the function object's constructor must receive all parameters it needs to work (except for the sequence of course). In our case, we receive the number of steps to use for each invocation.</p>
<p>Because our operator must step through elements of the sequence it is applied to, it needs to return a new sequence. Furthermore, that sequence must wrap the source sequence to be able to iterate its elements. One way to do this without implementing complex sequence logic is by using <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code>. This sequence wrapper's only requirement is that we implement a <em>next delegate</em>: a function that, when called, returns a pointer to the next element in the sequence, or <code>nullptr</code> when done. <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code> is used extensively in the <code>coveo::linq</code> library to implement LINQ operators.</p>
<p>Let's add a skeleton for a next delegate to our example:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl(Seq&amp;&amp; seq, std::site_t n) {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;typename coveo::seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), n_);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note the use of <code><a class="el" href="structcoveo_1_1seq__traits.html" title="Traits class for a sequence.">coveo::seq_traits</a></code> to produce a sequence of the same type of elements as the source sequence. Along with <code><a class="el" href="structcoveo_1_1seq__element__traits.html" title="Traits class for elements in a sequence.">coveo::seq_element_traits</a></code>, these can be used to simplify detection of sequence types in LINQ operator implementations.</p>
<p><code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code>'s implementation will <em>copy</em> the next delegate every time it is needed - in its copy/move constructors / assignment operators, but also when an iterator is fetched. This is done so that the state of the enumeration can be kept in the next delegate and copied as well. Because of this however, objects to be shared among delegates must be kept in shared memory as well - using <code>std::shared_ptr</code> for instance.</p>
<p>Let's add storage for our sequence in our example's next delegate:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">coveo::seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>internals {</div><div class="line">            Seq seq_;</div><div class="line">            iterator_type end_;</div><div class="line">            std::size_t n_;</div><div class="line"></div><div class="line">            internals(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  end_(std::end(seq_)),</div><div class="line">                  n_(n) { }</div><div class="line">            internals(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">            internals&amp; operator=(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> internals_sp = std::shared_ptr&lt;internals&gt;;</div><div class="line"></div><div class="line">        internals_sp spint_;</div><div class="line">        iterator_type it_;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">            : spint_(std::make_shared&lt;internals&gt;(std::forward&lt;Seq&gt;(seq), n)),</div><div class="line">              it_(std::begin(spint_-&gt;seq_)) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;typename coveo::seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), n_);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The <code>internals</code> class is used to keep all data that is to be shared among next delegates, including the sequence we're wrapping. This allows us to avoid copying the sequence for every delegate copy. The <code>internals</code> are kept in a <code>std::shared_ptr</code>.</p>
<p>Also note that we keep an <code>end</code> iterator in the <code>internals</code> object, but we keep another iterator in the next delegate directly. This is the <b>state</b> of the enumeration: the iterator points to the next element we'll be returning. This iterator is initialized at <code>begin</code> initially.</p>
<p>Now, all that is left is to implement the operator logic itself: iterating over the sequence, stepping through elements by a specific increment.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">coveo::seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>internals {</div><div class="line">            Seq seq_;</div><div class="line">            iterator_type end_;</div><div class="line">            std::size_t n_;</div><div class="line"></div><div class="line">            internals(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  end_(std::end(seq_)),</div><div class="line">                  n_(n) { }</div><div class="line">            internals(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">            internals&amp; operator=(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> internals_sp = std::shared_ptr&lt;internals&gt;;</div><div class="line"></div><div class="line">        internals_sp spint_;</div><div class="line">        iterator_type it_;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">            : spint_(std::make_shared&lt;internals&gt;(std::forward&lt;Seq&gt;(seq), n)),</div><div class="line">              it_(std::begin(spint_-&gt;seq_)) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">coveo::seq_traits&lt;Seq&gt;::pointer</a> {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">coveo::seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (it_ != spint_-&gt;end_) {</div><div class="line">                <span class="comment">// Return this element.</span></div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">coveo::seq_traits&lt;Seq&gt;::reference</a> robj = *it_;</div><div class="line">                pobj = std::addressof(robj);</div><div class="line"></div><div class="line">                <span class="comment">// Move to next element by stepping as appropriate.</span></div><div class="line">                <span class="keywordflow">for</span> (std::size_t i = 0; it_ != spint_-&gt;end_ &amp;&amp; i &lt; spint_-&gt;n_; ++i, ++it_) {</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;typename coveo::seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), n_);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">auto</span> step(std::size_t n) -&gt; step_impl&lt;&gt; {</div><div class="line">    <span class="keywordflow">return</span> step_impl&lt;&gt;(n);</div><div class="line">}</div></div><!-- fragment --><p>Note that we also added a "helper function" that returns our operator's function object's implementation. This function will be the one used to invoke our LINQ operator:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> NUMS[] = { 42, 23, 66, 11, 7, 67 };</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> seq = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(NUMS)</div><div class="line">         | step(2);</div><div class="line"><span class="comment">// seq == { 42, 66, 7 };</span></div></div><!-- fragment --><p>Implementing a terminal operator is even easier, because there's no need to provide a sequence implementation. Let's say we want to implement a <code>prod</code> operator that calculates the product of all sequence elements. Like the <code><a class="el" href="group__linq__op__sum.html#ga909514f1cd93d7f1c465418f4fddd102" title="Computes sum using numerical function.">coveo::linq::sum()</a></code> operator, it could be done by using a <em>numerical function</em> to get a numerical value for each sequence element. It could be done like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</div><div class="line"><span class="keyword">class </span>prod_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> F&amp; num_f_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> prod_impl(<span class="keyword">const</span> F&amp; num_f) : num_f_(num_f) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> std::decay&lt;decltype(num_f_(*std::begin(seq)))&gt;::type {</div><div class="line">        <span class="keyword">auto</span> it = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> end = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (it == end) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">coveo::linq::throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> product = num_f_(*it);</div><div class="line">        <span class="keywordflow">for</span> (++it; it != end; ++it) {</div><div class="line">            product *= num_f_(*it);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> product;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</div><div class="line"><span class="keyword">auto</span> prod(<span class="keyword">const</span> F&amp; num_f) -&gt; prod_impl&lt;F&gt; {</div><div class="line">    <span class="keywordflow">return</span> prod_impl&lt;F&gt;(num_f);</div><div class="line">}</div></div><!-- fragment --><p>Now, using the operator is as easy as using <code><a class="el" href="group__linq__op__sum.html#ga909514f1cd93d7f1c465418f4fddd102" title="Computes sum using numerical function.">coveo::linq::sum()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> NUMS[] = { 42, 23, 66 };</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> product = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(NUMS)</div><div class="line">             | prod([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i; });</div><div class="line"><span class="comment">// product == 63756</span></div></div><!-- fragment --><p>For more examples on how to implement LINQ operators, the easiest way is probably to have a look at the implementation of the operators included in the <code>coveo::linq</code> library itself. While the helper functions are documented <a class="el" href="group__linq__operators__list.html">here</a>, it is possible to look at the internal implementations in the file <a class="el" href="linq__detail_8h.html">coveo/linq/detail/linq_detail.h</a> :</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#ifndef COVEO_LINQ_DETAIL_H</span></div><div class="line"><span class="preprocessor">#define COVEO_LINQ_DETAIL_H</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="enumerable__detail_8h.html">coveo/seq/detail/enumerable_detail.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sequence__util_8h.html">coveo/seq/sequence_util.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstddef&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;forward_list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tuple&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>coveo {</div><div class="line"><span class="keyword">namespace </span>linq {</div><div class="line"><span class="keyword">namespace </span>detail {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>proxy_cmp</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> std::decay&lt;Pred&gt;::type* ppred_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> proxy_cmp(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : ppred_(std::addressof(pred)) { }</div><div class="line">    </div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp; left, U&amp;&amp; right) <span class="keyword">const</span> -&gt; decltype((*ppred_)(std::forward&lt;T&gt;(left), std::forward&lt;U&gt;(right))) {</div><div class="line">        <span class="keywordflow">return</span> (*ppred_)(std::forward&lt;T&gt;(left), std::forward&lt;U&gt;(right));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>deref_cmp</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Pred pred_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> deref_cmp(Pred&amp;&amp; pred)</div><div class="line">        : pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T* <span class="keyword">const</span> pleft, U* <span class="keyword">const</span> pright) <span class="keyword">const</span> -&gt; decltype(pred_(*pleft, *pright)) {</div><div class="line">        <span class="keywordflow">return</span> pred_(*pleft, *pright);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Selector&gt;</div><div class="line"><span class="keyword">class </span>indexless_selector_proxy</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Selector sel_;  <span class="comment">// Selector that doesn&#39;t care about index</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> indexless_selector_proxy(Selector&amp;&amp; sel)</div><div class="line">        : sel_(std::forward&lt;Selector&gt;(sel)) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp; element, std::size_t) -&gt; decltype(sel_(std::forward&lt;T&gt;(element))) {</div><div class="line">        <span class="keywordflow">return</span> sel_(std::forward&lt;T&gt;(element));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line"><span class="keyword">class </span>deref_next_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Struct storing sequence and ending. Shared among delegates.</span></div><div class="line">    <span class="keyword">struct </span>deref_info {</div><div class="line">        Seq seq_;               <span class="comment">// Sequence of pointers.</span></div><div class="line">        iterator_type iend_;    <span class="comment">// Iterator pointing at end of seq_.</span></div><div class="line"></div><div class="line">        <span class="keyword">explicit</span> deref_info(Seq&amp;&amp; seq)</div><div class="line">            : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">              iend_(std::end(seq_)) { }</div><div class="line"></div><div class="line">        <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">        deref_info(<span class="keyword">const</span> deref_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">        deref_info&amp; operator=(<span class="keyword">const</span> deref_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">    };</div><div class="line">    <span class="keyword">using</span> deref_info_sp = std::shared_ptr&lt;deref_info&gt;;</div><div class="line"></div><div class="line">    deref_info_sp spinfo_;      <span class="comment">// Shared sequence info.</span></div><div class="line">    iterator_type icur_;        <span class="comment">// Iterator pointing at current element.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> deref_next_impl(Seq&amp;&amp; seq)</div><div class="line">        : spinfo_(std::make_shared&lt;deref_info&gt;(std::forward&lt;Seq&gt;(seq))),</div><div class="line">          icur_(std::begin(spinfo_-&gt;seq_)) { }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#ab63386b3554c084783a8bd6b8f2a744d">seq_traits&lt;Seq&gt;::value_type</a> {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#ab63386b3554c084783a8bd6b8f2a744d">seq_traits&lt;Seq&gt;::value_type</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">        <span class="keywordflow">if</span> (icur_ != spinfo_-&gt;iend_) {</div><div class="line">            pobj = *icur_;</div><div class="line">            ++icur_;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> pobj;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line"><span class="keyword">auto</span> make_deref_next_impl(Seq&amp;&amp; seq) -&gt; deref_next_impl&lt;Seq&gt; {</div><div class="line">    <span class="keywordflow">return</span> deref_next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">struct </span>identity {</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp; obj) <span class="keyword">const</span> -&gt; decltype(std::forward&lt;T&gt;(obj)) {</div><div class="line">        <span class="keywordflow">return</span> std::forward&lt;T&gt;(obj);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">struct </span>pair_of {</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp; obj1, U&amp;&amp; obj2) <span class="keyword">const</span> -&gt; std::pair&lt;T, U&gt; {</div><div class="line">        <span class="keywordflow">return</span> std::pair&lt;T, U&gt;(std::forward&lt;T&gt;(obj1), std::forward&lt;U&gt;(obj2));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">struct </span>less {</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp; left, U&amp;&amp; right) <span class="keyword">const</span> -&gt; decltype(std::forward&lt;T&gt;(left) &lt; std::forward&lt;U&gt;(right)) {</div><div class="line">        <span class="keywordflow">return</span> std::forward&lt;T&gt;(left) &lt; std::forward&lt;U&gt;(right);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">struct </span>greater {</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp; left, U&amp;&amp; right) <span class="keyword">const</span> -&gt; decltype(std::forward&lt;T&gt;(left) &gt; std::forward&lt;U&gt;(right)) {</div><div class="line">        <span class="keywordflow">return</span> std::forward&lt;T&gt;(left) &gt; std::forward&lt;U&gt;(right);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="keyword">auto</span> make_unique(Args&amp;&amp;... args) -&gt; std::unique_ptr&lt;T&gt; {</div><div class="line">    <span class="keywordflow">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> T(std::forward&lt;Args&gt;(args)...));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</div><div class="line"><span class="keyword">class </span>aggregate_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> F&amp; agg_f_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> aggregate_impl_1(<span class="keyword">const</span> F&amp; agg_f)</div><div class="line">        : agg_f_(agg_f) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> std::decay&lt;decltype(*std::begin(seq))&gt;::type {</div><div class="line">        <span class="keyword">auto</span> it = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> end = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (it == end) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> <a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a>(*it);</div><div class="line">        <span class="keywordflow">for</span> (++it; it != end; ++it) {</div><div class="line">            <a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a> = agg_f_(<a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a>, *it);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Acc, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="keyword">class </span>aggregate_impl_2</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Acc&amp; seed_;</div><div class="line">    <span class="keyword">const</span> F&amp; agg_f_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    aggregate_impl_2(<span class="keyword">const</span> Acc&amp; seed, <span class="keyword">const</span> F&amp; agg_f)</div><div class="line">        : seed_(seed), agg_f_(agg_f) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; Acc {</div><div class="line">        Acc <a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a>(seed_);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; element : seq) {</div><div class="line">            <a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a> = agg_f_(<a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a>, element);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__linq__op__aggregate.html#gad45124e03053ced6f5b58c683dd73fee">aggregate</a>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Acc, <span class="keyword">typename</span> F, <span class="keyword">typename</span> RF&gt;</div><div class="line"><span class="keyword">class </span>aggregate_impl_3 : <span class="keyword">public</span> aggregate_impl_2&lt;Acc, F&gt;</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> RF&amp; result_f_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    aggregate_impl_3(<span class="keyword">const</span> Acc&amp; seed, <span class="keyword">const</span> F&amp; agg_f, <span class="keyword">const</span> RF&amp; result_f)</div><div class="line">        : aggregate_impl_2&lt;Acc, F&gt;(seed, agg_f), result_f_(result_f) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(result_f_(std::declval&lt;Acc&gt;())) {</div><div class="line">        <span class="keywordflow">return</span> result_f_(aggregate_impl_2&lt;Acc, F&gt;::operator()(seq));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>all_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> all_impl(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keywordflow">return</span> std::all_of(std::begin(seq), std::end(seq), pred_);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>any_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keywordflow">return</span> std::begin(seq) != std::end(seq);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>any_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> any_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keywordflow">return</span> std::any_of(std::begin(seq), std::end(seq), pred_);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</div><div class="line"><span class="keyword">class </span>average_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> F&amp; num_f_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> average_impl(<span class="keyword">const</span> F&amp; num_f)</div><div class="line">        : num_f_(num_f) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <span class="keyword">typename</span> std::decay&lt;decltype(num_f_(*std::begin(seq)))&gt;::type</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> it = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> end = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (it == end) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> total = num_f_(*it);</div><div class="line">        decltype(total) <a class="code" href="group__linq__op__count.html#gadc1b9f5f29d224edabd021389facc2b8">count</a> = 1;</div><div class="line">        <span class="keywordflow">for</span> (++it; it != end; ++it) {</div><div class="line">            total += num_f_(*it);</div><div class="line">            ++<a class="code" href="group__linq__op__count.html#gadc1b9f5f29d224edabd021389facc2b8">count</a>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> total / <a class="code" href="group__linq__op__count.html#gadc1b9f5f29d224edabd021389facc2b8">count</a>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</div><div class="line"><span class="keyword">class </span>cast_selector</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp; obj) <span class="keyword">const</span> -&gt; U {</div><div class="line">        <span class="keywordflow">return</span> static_cast&lt;U&gt;(obj);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq2&gt;</div><div class="line"><span class="keyword">class </span>concat_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that concatenates two sequences</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// Type of element returned by this next delegate. The elements will be const</span></div><div class="line">        <span class="comment">// if at least one sequence is const.</span></div><div class="line">        <span class="keyword">using</span> enum_type         = <span class="keyword">typename</span> std::conditional&lt;std::is_const&lt;typename seq_traits&lt;Seq1&gt;::value_type&gt;::value ||</div><div class="line">                                                            std::is_const&lt;typename seq_traits&lt;Seq2&gt;::value_type&gt;::value,</div><div class="line">                                                            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#aa574bb61aefed9bf9336a7c59c4b9ba4">seq_traits&lt;Seq1&gt;::const_value_type</a>,</div><div class="line">                                                            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#ab63386b3554c084783a8bd6b8f2a744d">seq_traits&lt;Seq1&gt;::value_type</a>&gt;::type;</div><div class="line">        <span class="keyword">using</span> enum_pointer      = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_element_traits&lt;enum_type&gt;::pointer</a>;</div><div class="line">        <span class="keyword">using</span> enum_reference    = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_element_traits&lt;enum_type&gt;::reference</a>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Type of iterators for both sequences</span></div><div class="line">        <span class="keyword">using</span> first_iterator_type   = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq1&gt;::iterator_type</a>;</div><div class="line">        <span class="keyword">using</span> second_iterator_type  = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq2&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Information used to concatenate sequences. Shared among delegates.</span></div><div class="line">        <span class="keyword">class </span>concat_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            Seq1 seq1_;                     <span class="comment">// First sequence to concatenate</span></div><div class="line">            first_iterator_type iend1_;     <span class="comment">// End of first sequence</span></div><div class="line">            Seq2 seq2_;                     <span class="comment">// Second sequence to concatenate</span></div><div class="line">            second_iterator_type iend2_;    <span class="comment">// End of second sequence</span></div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            concat_info(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2)</div><div class="line">                : seq1_(std::forward&lt;Seq1&gt;(seq1)),</div><div class="line">                  iend1_(std::end(seq1_)),</div><div class="line">                  seq2_(std::forward&lt;Seq2&gt;(seq2)),</div><div class="line">                  iend2_(std::end(seq2_)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot move/copy, stored in a shared_ptr</span></div><div class="line">            concat_info(<span class="keyword">const</span> concat_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            concat_info&amp; operator=(<span class="keyword">const</span> concat_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            first_iterator_type first_begin() {</div><div class="line">                <span class="keywordflow">return</span> std::begin(seq1_);</div><div class="line">            }</div><div class="line">            second_iterator_type second_begin() {</div><div class="line">                <span class="keywordflow">return</span> std::begin(seq2_);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Returns next element from one of the sequences or nullptr when done</span></div><div class="line">            <span class="keyword">auto</span> get_next(first_iterator_type&amp; icur1, second_iterator_type&amp; icur2) -&gt; enum_pointer {</div><div class="line">                <span class="comment">// First return all elements from first sequence, then from second sequence.</span></div><div class="line">                enum_pointer pobj = <span class="keyword">nullptr</span>;</div><div class="line">                <span class="keywordflow">if</span> (icur1 != iend1_) {</div><div class="line">                    enum_reference robj = *icur1;</div><div class="line">                    pobj = std::addressof(robj);</div><div class="line">                    ++icur1;</div><div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (icur2 != iend2_) {</div><div class="line">                    enum_reference robj = *icur2;</div><div class="line">                    pobj = std::addressof(robj);</div><div class="line">                    ++icur2;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> pobj;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> concat_info_sp = std::shared_ptr&lt;concat_info&gt;;</div><div class="line"></div><div class="line">        concat_info_sp spinfo_;         <span class="comment">// Shared concat info</span></div><div class="line">        first_iterator_type icur1_;     <span class="comment">// Current position in first sequence</span></div><div class="line">        second_iterator_type icur2_;    <span class="comment">// Current position in second sequence</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2)</div><div class="line">            : spinfo_(std::make_shared&lt;concat_info&gt;(std::forward&lt;Seq1&gt;(seq1), std::forward&lt;Seq2&gt;(seq2))),</div><div class="line">              icur1_(spinfo_-&gt;first_begin()), icur2_(spinfo_-&gt;second_begin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; decltype(spinfo_-&gt;get_next(icur1_, icur2_)) {</div><div class="line">            <span class="keywordflow">return</span> spinfo_-&gt;get_next(icur1_, icur2_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Seq2 seq2_;     <span class="comment">// Second sequence (possibly a ref)</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> concat_impl(Seq2&amp;&amp; seq2)</div><div class="line">        : seq2_(std::forward&lt;Seq2&gt;(seq2)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    concat_impl(<span class="keyword">const</span> concat_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    concat_impl(concat_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    concat_impl&amp; operator=(<span class="keyword">const</span> concat_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    concat_impl&amp; operator=(concat_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq1&amp;&amp; seq1)</div><div class="line">        -&gt; enumerable&lt;typename next_impl&lt;Seq1&gt;::enum_type&gt;</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> siz1 = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq1);</div><div class="line">        <span class="keyword">auto</span> siz2 = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq2_);</div><div class="line">        <span class="keyword">typename</span> enumerable&lt;typename next_impl&lt;Seq1&gt;::enum_type&gt;::size_delegate siz;</div><div class="line">        <span class="keywordflow">if</span> (siz1 != <span class="keyword">nullptr</span> &amp;&amp; siz2 != <span class="keyword">nullptr</span>) {</div><div class="line">            std::size_t size = siz1() + siz2();</div><div class="line">            siz = [size]() -&gt; std::size_t { <span class="keywordflow">return</span> size; };</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> { next_impl&lt;Seq1&gt;(std::forward&lt;Seq1&gt;(seq1), std::forward&lt;Seq2&gt;(seq2_)),</div><div class="line">                 siz };</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class </span>contains_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> T&amp; obj_;  <span class="comment">// Object to look for.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> contains_impl_1(<span class="keyword">const</span> T&amp; obj)</div><div class="line">        : obj_(obj) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; element : seq) {</div><div class="line">            <span class="keywordflow">if</span> (element == obj_) {</div><div class="line">                found = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> found;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>contains_impl_2</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> T&amp; obj_;      <span class="comment">// Object to look for.</span></div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate used to compare objects.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    contains_impl_2(<span class="keyword">const</span> T&amp; obj, <span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : obj_(obj), pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; element : seq) {</div><div class="line">            <span class="keywordflow">if</span> (pred_(element, obj_)) {</div><div class="line">                found = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> found;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>count_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Used if sequence has size() method</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq,</div><div class="line">             <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;coveo::detail::has_size_const_method&lt;typename std::decay&lt;Seq&gt;::type&gt;::value, <span class="keywordtype">void</span>&gt;::type&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq) -&gt; std::size_t {</div><div class="line">        <span class="keywordflow">return</span> seq.size();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Used otherwise (no choice but to use distance)</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq,</div><div class="line">             <span class="keyword">typename</span> _V = <span class="keyword">typename</span> std::enable_if&lt;!coveo::detail::has_size_const_method&lt;typename std::decay&lt;Seq&gt;::type&gt;::value, <span class="keywordtype">void</span>*&gt;::type&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, _V = <span class="keyword">nullptr</span>) -&gt; std::size_t {</div><div class="line">        <span class="keywordflow">return</span> static_cast&lt;std::size_t&gt;(std::distance(std::begin(seq), std::end(seq)));</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; std::size_t {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>count_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> count_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; std::size_t {</div><div class="line">        <span class="keywordflow">return</span> static_cast&lt;std::size_t&gt;(std::count_if(std::begin(seq), std::end(seq), pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>default_if_empty_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; enumerable&lt;typename seq_traits&lt;Seq&gt;::const_value_type&gt;</div><div class="line">    {</div><div class="line">        enumerable&lt;typename seq_traits&lt;Seq&gt;::const_value_type&gt; e;</div><div class="line">        <span class="keywordflow">if</span> (any_impl_0&lt;&gt;()(std::forward&lt;Seq&gt;(seq))) {</div><div class="line">            e = <a class="code" href="seq_2enumerable_8h.html#a139c4f7171bfeb63c4f27d4ab6642975">enumerate_container</a>(std::forward&lt;Seq&gt;(seq));</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            e = <a class="code" href="seq_2enumerable_8h.html#a32f6db3c165592bc9ed3b7a249c8edd7">enumerate_one</a>(<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>());</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> e;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class </span>default_if_empty_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> T&amp; obj_;  <span class="comment">// Object to use to create default value if empty.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> default_if_empty_impl_1(<span class="keyword">const</span> T&amp; obj)</div><div class="line">        : obj_(obj) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; enumerable&lt;typename seq_traits&lt;Seq&gt;::const_value_type&gt;</div><div class="line">    {</div><div class="line">        enumerable&lt;typename seq_traits&lt;Seq&gt;::const_value_type&gt; e;</div><div class="line">        <span class="keywordflow">if</span> (any_impl_0&lt;&gt;()(std::forward&lt;Seq&gt;(seq))) {</div><div class="line">            e = <a class="code" href="seq_2enumerable_8h.html#a139c4f7171bfeb63c4f27d4ab6642975">enumerate_container</a>(std::forward&lt;Seq&gt;(seq));</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            e = <a class="code" href="seq_2enumerable_8h.html#a32f6db3c165592bc9ed3b7a249c8edd7">enumerate_one</a>(<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>(obj_));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> e;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>distinct_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that filters duplicate elements</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Type of iterator for the sequence</span></div><div class="line">        <span class="keyword">using</span> iterator_type     = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Set storing pointers to seen elements</span></div><div class="line">        <span class="keyword">using</span> seen_elements_set = std::set&lt;typename seq_traits&lt;Seq&gt;::const_pointer, deref_cmp&lt;proxy_cmp&lt;Pred&gt;&gt;&gt;;</div><div class="line"></div><div class="line">        <span class="comment">// Info used to produce distinct elements. Shared among delegates.</span></div><div class="line">        <span class="keyword">class </span>distinct_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            Seq seq_;               <span class="comment">// Sequence being iterated</span></div><div class="line">            iterator_type iend_;    <span class="comment">// Iterator pointing at end of sequence</span></div><div class="line">            Pred pred_;             <span class="comment">// Predicate ordering the elements</span></div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            distinct_info(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  iend_(std::end(seq_)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            distinct_info(<span class="keyword">const</span> distinct_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            distinct_info&amp; operator=(<span class="keyword">const</span> distinct_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            iterator_type seq_begin() {</div><div class="line">                <span class="keywordflow">return</span> std::begin(seq_);</div><div class="line">            }</div><div class="line">            seen_elements_set init_seen_elements() {</div><div class="line">                <span class="keywordflow">return</span> seen_elements_set(deref_cmp&lt;proxy_cmp&lt;Pred&gt;&gt;(proxy_cmp&lt;Pred&gt;(pred_)));</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Returns next distinct element or nullptr when done</span></div><div class="line">            <span class="keyword">auto</span> get_next(iterator_type&amp; icur, seen_elements_set&amp; seen)</div><div class="line">                -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a></div><div class="line">            {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">                <span class="keywordflow">for</span> (; pobj == <span class="keyword">nullptr</span> &amp;&amp; icur != iend_; ++icur) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a> robjtmp = *icur;</div><div class="line">                    <span class="keyword">auto</span> pobjtmp = std::addressof(robjtmp);</div><div class="line">                    <span class="keywordflow">if</span> (seen.emplace(pobjtmp).second) {</div><div class="line">                        <span class="comment">// Not seen yet, return this element.</span></div><div class="line">                        pobj = pobjtmp;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> pobj;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> distinct_info_sp = std::shared_ptr&lt;distinct_info&gt;;</div><div class="line"></div><div class="line">        distinct_info_sp spinfo_;   <span class="comment">// Shared info</span></div><div class="line">        iterator_type icur_;        <span class="comment">// Iterator pointing at current element</span></div><div class="line">        seen_elements_set seen_;    <span class="comment">// Set of seen elements</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">            : spinfo_(std::make_shared&lt;distinct_info&gt;(std::forward&lt;Seq&gt;(seq), std::forward&lt;Pred&gt;(pred))),</div><div class="line">              icur_(spinfo_-&gt;seq_begin()), seen_(spinfo_-&gt;init_seen_elements()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; decltype(spinfo_-&gt;get_next(icur_, seen_)) {</div><div class="line">            <span class="keywordflow">return</span> spinfo_-&gt;get_next(icur_, seen_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Pred pred_;     <span class="comment">// Predicate used to compare elements</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> distinct_impl(Pred&amp;&amp; pred)</div><div class="line">        : pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    distinct_impl(<span class="keyword">const</span> distinct_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    distinct_impl(distinct_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    distinct_impl&amp; operator=(<span class="keyword">const</span> distinct_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    distinct_impl&amp; operator=(distinct_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>element_at_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;     <span class="comment">// Index of element to fetch.</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// If we have random-access iterators, we can perform fast computations</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::random_access_iterator_tag) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (static_cast&lt;std::size_t&gt;(iend - icur) &lt;= n_) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        icur += n_;</div><div class="line">        <span class="keywordflow">return</span> *icur;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise, we can only move by hand</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::input_iterator_tag) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n_ &amp;&amp; icur != iend; ++i, ++icur) {</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (icur == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *icur;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> element_at_impl(std::size_t n)</div><div class="line">        : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq),</div><div class="line">                    <span class="keyword">typename</span> std::iterator_traits&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>&gt;::iterator_category());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>element_at_or_default_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;     <span class="comment">// Index of element to fetch.</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// If we have random-access iterators, we can perform fast computations</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::random_access_iterator_tag) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">return</span> static_cast&lt;std::size_t&gt;(iend - icur) &gt; n_ ? *(icur + n_)</div><div class="line">                                                          : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise, we can only move by hand</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::input_iterator_tag) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n_ &amp;&amp; icur != iend; ++i, ++icur) {</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> icur != iend ? *icur</div><div class="line">                            : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    element_at_or_default_impl(std::size_t n)</div><div class="line">        : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq),</div><div class="line">                    <span class="keyword">typename</span> std::iterator_traits&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>&gt;::iterator_category());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq2, <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>except_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that filters out elements in the second sequence</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Vector of pointers to elements in the second sequence. Used to filter them out.</span></div><div class="line">        <span class="keyword">using</span> elements_to_filter_v  = std::vector&lt;typename seq_traits&lt;Seq2&gt;::const_pointer&gt;;</div><div class="line"></div><div class="line">        <span class="comment">// Type of iterator for the first sequence.</span></div><div class="line">        <span class="keyword">using</span> first_iterator_type   = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq1&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Bean storing info about elements to filter out. Shared among delegate instances.</span></div><div class="line">        <span class="keyword">class </span>filter_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            Seq1 seq1_;                         <span class="comment">// Sequence of elements to scan and return.</span></div><div class="line">            first_iterator_type iend1_;         <span class="comment">// End of seq1_.</span></div><div class="line">            Seq2 seq2_;                         <span class="comment">// Sequence of elements to filter out.</span></div><div class="line">            deref_cmp&lt;Pred&gt; pred_;              <span class="comment">// Predicate used to sort and search through v_to_filter_.</span></div><div class="line">            elements_to_filter_v v_to_filter_;  <span class="comment">// Elements to filter out. Late-initialized.</span></div><div class="line">            <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;          <span class="comment">// Init flag for v_to_filter_.</span></div><div class="line"></div><div class="line">            <span class="keywordtype">void</span> init() {</div><div class="line">                <a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(v_to_filter_, seq2_);</div><div class="line">                <span class="keyword">auto</span> icur2 = std::begin(seq2_);</div><div class="line">                <span class="keyword">auto</span> iend2 = std::end(seq2_);</div><div class="line">                <span class="keywordflow">for</span> (; icur2 != iend2; ++icur2) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#acd4bad5382d0253647e7df4257fe6c5a">seq_traits&lt;Seq2&gt;::const_reference</a> robjtmp = *icur2;</div><div class="line">                    v_to_filter_.emplace_back(std::addressof(robjtmp));</div><div class="line">                }</div><div class="line">                std::sort(v_to_filter_.begin(), v_to_filter_.end(), pred_);</div><div class="line">                init_called_ = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            filter_info(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">                : seq1_(std::forward&lt;Seq1&gt;(seq1)), iend1_(std::end(seq1_)),</div><div class="line">                  seq2_(std::forward&lt;Seq2&gt;(seq2)), pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// No move or copy, it&#39;s stored in a shared_ptr</span></div><div class="line">            filter_info(<span class="keyword">const</span> filter_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            filter_info&amp; operator=(<span class="keyword">const</span> filter_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            first_iterator_type first_begin() {</div><div class="line">                <span class="keywordflow">return</span> std::begin(seq1_);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> filtered(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq1&gt;::pointer</a> pobj) {</div><div class="line">                <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                    <span class="comment">// Init elements to filter on first call</span></div><div class="line">                    init();</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> std::binary_search(v_to_filter_.cbegin(), v_to_filter_.cend(), pobj, pred_);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Returns next non-filtered element or nullptr when done</span></div><div class="line">            <span class="keyword">auto</span> get_next(first_iterator_type&amp; icur1) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq1&gt;::pointer</a> {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq1&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">                <span class="keywordflow">for</span> (; pobj == <span class="keyword">nullptr</span> &amp;&amp; icur1 != iend1_; ++icur1) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq1&gt;::reference</a> robjtmp = *icur1;</div><div class="line">                    <span class="keyword">auto</span> pobjtmp = std::addressof(robjtmp);</div><div class="line">                    <span class="keywordflow">if</span> (!filtered(pobjtmp)) {</div><div class="line">                        pobj = pobjtmp;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> pobj;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> filter_info_sp = std::shared_ptr&lt;filter_info&gt;;</div><div class="line"></div><div class="line">        filter_info_sp spfilter_;   <span class="comment">// Bean containing filter info</span></div><div class="line">        first_iterator_type icur_;  <span class="comment">// Current position in first sequence</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">            : spfilter_(std::make_shared&lt;filter_info&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                                                      std::forward&lt;Seq2&gt;(seq2),</div><div class="line">                                                      std::forward&lt;Pred&gt;(pred))),</div><div class="line">              icur_(spfilter_-&gt;first_begin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; decltype(spfilter_-&gt;get_next(icur_)) {</div><div class="line">            <span class="keywordflow">return</span> spfilter_-&gt;get_next(icur_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Seq2 seq2_;     <span class="comment">// Sequence of elements to filter out</span></div><div class="line">    Pred pred_;     <span class="comment">// Predicate used to compare elements</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    except_impl(Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">        : seq2_(std::forward&lt;Seq2&gt;(seq2)), pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    except_impl(<span class="keyword">const</span> except_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    except_impl(except_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    except_impl&amp; operator=(<span class="keyword">const</span> except_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    except_impl&amp; operator=(except_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq1&amp;&amp; seq1)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq1&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq1&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                               std::forward&lt;Seq2&gt;(seq2_),</div><div class="line">                               std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>first_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keywordflow">if</span> (icur == std::end(seq)) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *icur;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>first_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> first_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (icur == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> ifound = std::find_if(icur, iend, pred_);</div><div class="line">        <span class="keywordflow">if</span> (ifound == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *ifound;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>first_or_default_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keywordflow">return</span> icur != std::end(seq) ? *icur</div><div class="line">                                     : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>first_or_default_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> first_or_default_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keyword">auto</span> ifound = std::find_if(std::begin(seq), iend, pred_);</div><div class="line">        <span class="keywordflow">return</span> ifound != iend ? *ifound</div><div class="line">                              : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeySelector,</div><div class="line">         <span class="keyword">typename</span> ValueSelector,</div><div class="line">         <span class="keyword">typename</span> ResultSelector,</div><div class="line">         <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>group_by_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that returns group information</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// Key and value types returned by selectors.</span></div><div class="line">        <span class="keyword">using</span> key               = decltype(std::declval&lt;KeySelector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a>&gt;()));</div><div class="line">        <span class="keyword">using</span> value             = decltype(std::declval&lt;ValueSelector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a>&gt;()));</div><div class="line"></div><div class="line">        <span class="comment">// Vector of values sharing a common key.</span></div><div class="line">        <span class="keyword">using</span> value_v           = std::vector&lt;typename std::decay&lt;value&gt;::type&gt;;</div><div class="line">        <span class="keyword">using</span> values            = decltype(<a class="code" href="seq_2enumerable_8h.html#a139c4f7171bfeb63c4f27d4ab6642975">enumerate_container</a>(std::declval&lt;value_v&amp;&amp;&gt;()));</div><div class="line"></div><div class="line">        <span class="comment">// Map that stores keys and their corresponding values.</span></div><div class="line">        <span class="keyword">using</span> values_by_key_m   = std::map&lt;typename std::decay&lt;key&gt;::type, value_v, proxy_cmp&lt;Pred&gt;&gt;;</div><div class="line"></div><div class="line">        <span class="comment">// Result returned by result selector.</span></div><div class="line">        <span class="keyword">using</span> result            = decltype(std::declval&lt;ResultSelector&gt;()(std::declval&lt;key&gt;(), std::declval&lt;values&gt;()));</div><div class="line"></div><div class="line">        <span class="comment">// Vector of results returned by this next delegate.</span></div><div class="line">        <span class="keyword">using</span> result_v          = std::vector&lt;typename std::decay&lt;result&gt;::type&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Bean storing group information. Shared among delegates in a shared_ptr.</span></div><div class="line">        <span class="keyword">class </span>groups_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            Seq seq_;                       <span class="comment">// Sequence containing the elements</span></div><div class="line">            KeySelector key_sel_;           <span class="comment">// Returns keys for elements</span></div><div class="line">            ValueSelector value_sel_;       <span class="comment">// Returns values for elements</span></div><div class="line">            ResultSelector result_sel_;     <span class="comment">// Converts groups into end results</span></div><div class="line">            Pred pred_;                     <span class="comment">// Compares keys</span></div><div class="line">            result_v results_;              <span class="comment">// Vector of end results</span></div><div class="line">            <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;      <span class="comment">// Whether results_ has been initialized</span></div><div class="line"></div><div class="line">            <span class="keywordtype">void</span> init() {</div><div class="line">                <span class="comment">// First build map of groups</span></div><div class="line">                values_by_key_m groups{proxy_cmp&lt;Pred&gt;(pred_)};</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; obj : seq_) {</div><div class="line">                    groups[key_sel_(obj)].emplace_back(value_sel_(obj));</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// Now build vector of results</span></div><div class="line">                <span class="comment">// Note that since we no longer need the map afterwards, we can actually move</span></div><div class="line">                <span class="comment">// the vectors stored as map values into the results vector.</span></div><div class="line">                results_.reserve(groups.size());</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; group_pair : groups) {</div><div class="line">                    results_.emplace_back(result_sel_(group_pair.first,</div><div class="line">                                                      <a class="code" href="seq_2enumerable_8h.html#a139c4f7171bfeb63c4f27d4ab6642975">enumerate_container</a>(std::move(group_pair.second))));</div><div class="line">                }</div><div class="line"></div><div class="line">                init_called_ = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            groups_info(Seq&amp;&amp; seq, KeySelector&amp;&amp; key_sel, ValueSelector&amp;&amp; value_sel,</div><div class="line">                        ResultSelector&amp;&amp; result_sel, Pred&amp;&amp; pred)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  key_sel_(std::forward&lt;KeySelector&gt;(key_sel)),</div><div class="line">                  value_sel_(std::forward&lt;ValueSelector&gt;(value_sel)),</div><div class="line">                  result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Not copyable/movable, stored in a shared_ptr</span></div><div class="line">            groups_info(<span class="keyword">const</span> groups_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            groups_info&amp; operator=(<span class="keyword">const</span> groups_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> result_v&amp; get_results() {</div><div class="line">                <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                    init();</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> results_;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> groups_info_sp = std::shared_ptr&lt;groups_info&gt;;</div><div class="line"></div><div class="line">        groups_info_sp spgroups_;                   <span class="comment">// Information about groups</span></div><div class="line">        <span class="keyword">typename</span> result_v::const_iterator icurr_{}; <span class="comment">// Iterator pointing at current result.</span></div><div class="line">        <span class="keyword">typename</span> result_v::const_iterator iendr_{}; <span class="comment">// Iterator pointing at end of result vector.</span></div><div class="line">        <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;                  <span class="comment">// Whether icurr_ and iendr_ have been initialized</span></div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> init() {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; results = spgroups_-&gt;get_results();</div><div class="line">            icurr_ = std::begin(results);</div><div class="line">            iendr_ = std::end(results);</div><div class="line">            init_called_ = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq&amp;&amp; seq, KeySelector&amp;&amp; key_sel, ValueSelector&amp;&amp; value_sel,</div><div class="line">                  ResultSelector&amp;&amp; result_sel, Pred&amp;&amp; pred)</div><div class="line">            : spgroups_(std::make_shared&lt;groups_info&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                      std::forward&lt;KeySelector&gt;(key_sel),</div><div class="line">                                                      std::forward&lt;ValueSelector&gt;(value_sel),</div><div class="line">                                                      std::forward&lt;ResultSelector&gt;(result_sel),</div><div class="line">                                                      std::forward&lt;Pred&gt;(pred))) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a0e164e3da2482c98fa0d7dd87b25b77a">seq_traits&lt;result_v&gt;::const_pointer</a> {</div><div class="line">            <span class="comment">// Init iterators on first call</span></div><div class="line">            <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                init();</div><div class="line">            }</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a0e164e3da2482c98fa0d7dd87b25b77a">seq_traits&lt;result_v&gt;::const_pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (icurr_ != iendr_) {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#acd4bad5382d0253647e7df4257fe6c5a">seq_traits&lt;result_v&gt;::const_reference</a> robj = *icurr_;</div><div class="line">                pobj = std::addressof(robj);</div><div class="line">                ++icurr_;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    KeySelector key_sel_;       <span class="comment">// Selector that provides keys for each element</span></div><div class="line">    ValueSelector value_sel_;   <span class="comment">// Selector that provides values for each element</span></div><div class="line">    ResultSelector result_sel_; <span class="comment">// Selector that converts each group into a final result</span></div><div class="line">    Pred pred_;                 <span class="comment">// Predicate used to compare keys</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    group_by_impl(KeySelector&amp;&amp; key_sel, ValueSelector&amp;&amp; value_sel,</div><div class="line">                  ResultSelector&amp;&amp; result_sel, Pred&amp;&amp; pred)</div><div class="line">        : key_sel_(std::forward&lt;KeySelector&gt;(key_sel)),</div><div class="line">          value_sel_(std::forward&lt;ValueSelector&gt;(value_sel)),</div><div class="line">          result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)),</div><div class="line">          pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    group_by_impl(<span class="keyword">const</span> group_by_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    group_by_impl(group_by_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    group_by_impl&amp; operator=(<span class="keyword">const</span> group_by_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    group_by_impl&amp; operator=(group_by_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; enumerable&lt;typename seq_traits&lt;typename next_impl&lt;Seq&gt;::result_v&gt;::const_value_type&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                              std::forward&lt;KeySelector&gt;(key_sel_),</div><div class="line">                              std::forward&lt;ValueSelector&gt;(value_sel_),</div><div class="line">                              std::forward&lt;ResultSelector&gt;(result_sel_),</div><div class="line">                              std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InnerSeq,</div><div class="line">         <span class="keyword">typename</span> OuterKeySelector,</div><div class="line">         <span class="keyword">typename</span> InnerKeySelector,</div><div class="line">         <span class="keyword">typename</span> ResultSelector,</div><div class="line">         <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>group_join_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that returns final results</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OuterSeq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// Key returned by key selectors.</span></div><div class="line">        <span class="keyword">using</span> key               = decltype(std::declval&lt;OuterKeySelector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;OuterSeq&gt;::reference</a>&gt;()));</div><div class="line"></div><div class="line">        <span class="comment">// Group of pointers to elements from the inner sequence that share a common key.</span></div><div class="line">        <span class="keyword">using</span> inner_element_v   = std::vector&lt;typename seq_traits&lt;InnerSeq&gt;::pointer&gt;;</div><div class="line">        <span class="keyword">using</span> inner_elements    = enumerable&lt;typename seq_traits&lt;InnerSeq&gt;::const_value_type&gt;;</div><div class="line">    </div><div class="line">        <span class="comment">// Result returned by result selector.</span></div><div class="line">        <span class="keyword">using</span> result            = decltype(std::declval&lt;ResultSelector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;OuterSeq&gt;::reference</a>&gt;(),</div><div class="line">                                                                          std::declval&lt;inner_elements&gt;()));</div><div class="line"></div><div class="line">        <span class="comment">// Vector of results returned by this next delegate.</span></div><div class="line">        <span class="keyword">using</span> result_v          = std::vector&lt;typename std::decay&lt;result&gt;::type&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Bean storing groups information. Shared among delegates in a shared_ptr.</span></div><div class="line">        <span class="keyword">class </span>groups_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            OuterSeq outer_seq_;                <span class="comment">// Outer sequence.</span></div><div class="line">            InnerSeq inner_seq_;                <span class="comment">// Inner sequence from which to create groups.</span></div><div class="line">            OuterKeySelector outer_key_sel_;    <span class="comment">// Key selector for outer sequence.</span></div><div class="line">            InnerKeySelector inner_key_sel_;    <span class="comment">// Key selector for inner sequence.</span></div><div class="line">            ResultSelector result_sel_;         <span class="comment">// Selector converting groups into final results.</span></div><div class="line">            Pred pred_;                         <span class="comment">// Predicate used to compare keys.</span></div><div class="line">            result_v results_;                  <span class="comment">// Vector of final results.</span></div><div class="line">            <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;          <span class="comment">// Whether results_ has been initialized.</span></div><div class="line"></div><div class="line">            <span class="keywordtype">void</span> init() {</div><div class="line">                <span class="comment">// Build map of groups of elements from inner sequence.</span></div><div class="line">                <span class="keyword">using</span> groups_m = std::map&lt;typename std::decay&lt;key&gt;::type, inner_element_v, proxy_cmp&lt;Pred&gt;&gt;;</div><div class="line">                groups_m keyed_inner_elems{proxy_cmp&lt;Pred&gt;(pred_)};</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; inner_elem : inner_seq_) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;InnerSeq&gt;::reference</a> robj = inner_elem;</div><div class="line">                    keyed_inner_elems[inner_key_sel_(inner_elem)].emplace_back(std::addressof(robj));</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// Iterate outer sequence and build final results by matching the elements with</span></div><div class="line">                <span class="comment">// the groups we built earlier.</span></div><div class="line">                <a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(results_, outer_seq_);</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> iendki = keyed_inner_elems.end();</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; outer_elem : outer_seq_) {</div><div class="line">                    <span class="keyword">const</span> key outer_key = outer_key_sel_(outer_elem);</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> icurki = keyed_inner_elems.find(outer_key);</div><div class="line">                    inner_elements inner_elems;</div><div class="line">                    <span class="keywordflow">if</span> (icurki != iendki) {</div><div class="line">                        <span class="keyword">const</span> std::size_t inner_size = icurki-&gt;second.size();</div><div class="line">                        inner_elems = inner_elements(make_deref_next_impl(icurki-&gt;second),</div><div class="line">                                                     [inner_size]() -&gt; std::size_t { return inner_size; });</div><div class="line">                    }</div><div class="line">                    results_.emplace_back(result_sel_(outer_elem, inner_elems));</div><div class="line">                }</div><div class="line"></div><div class="line">                init_called_ = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            groups_info(OuterSeq&amp;&amp; outer_seq, InnerSeq&amp;&amp; inner_seq,</div><div class="line">                        OuterKeySelector&amp;&amp; outer_key_sel, InnerKeySelector&amp;&amp; inner_key_sel,</div><div class="line">                        ResultSelector&amp;&amp; result_sel, Pred&amp;&amp; pred)</div><div class="line">                : outer_seq_(std::forward&lt;OuterSeq&gt;(outer_seq)),</div><div class="line">                  inner_seq_(std::forward&lt;InnerSeq&gt;(inner_seq)),</div><div class="line">                  outer_key_sel_(std::forward&lt;OuterKeySelector&gt;(outer_key_sel)),</div><div class="line">                  inner_key_sel_(std::forward&lt;InnerKeySelector&gt;(inner_key_sel)),</div><div class="line">                  result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Not copyable/movable, stored in a shared_ptr</span></div><div class="line">            groups_info(<span class="keyword">const</span> groups_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            groups_info&amp; operator=(<span class="keyword">const</span> groups_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> result_v&amp; get_results() {</div><div class="line">                <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                    init();</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> results_;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> groups_info_sp = std::shared_ptr&lt;groups_info&gt;;</div><div class="line"></div><div class="line">        groups_info_sp spgroups_;                   <span class="comment">// Information about groups and results</span></div><div class="line">        <span class="keyword">typename</span> result_v::const_iterator icurr_{}; <span class="comment">// Iterator pointing at current result.</span></div><div class="line">        <span class="keyword">typename</span> result_v::const_iterator iendr_{}; <span class="comment">// Iterator pointing at end of result vector.</span></div><div class="line">        <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;                  <span class="comment">// Whether icurr_/iendr_ have been initialized.</span></div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> init() {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; results = spgroups_-&gt;get_results();</div><div class="line">            icurr_ = std::begin(results);</div><div class="line">            iendr_ = std::end(results);</div><div class="line">            init_called_ = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(OuterSeq&amp;&amp; outer_seq, InnerSeq&amp;&amp; inner_seq,</div><div class="line">                  OuterKeySelector&amp;&amp; outer_key_sel, InnerKeySelector&amp;&amp; inner_key_sel,</div><div class="line">                  ResultSelector&amp;&amp; result_sel, Pred&amp;&amp; pred)</div><div class="line">            : spgroups_(std::make_shared&lt;groups_info&gt;(std::forward&lt;OuterSeq&gt;(outer_seq),</div><div class="line">                                                      std::forward&lt;InnerSeq&gt;(inner_seq),</div><div class="line">                                                      std::forward&lt;OuterKeySelector&gt;(outer_key_sel),</div><div class="line">                                                      std::forward&lt;InnerKeySelector&gt;(inner_key_sel),</div><div class="line">                                                      std::forward&lt;ResultSelector&gt;(result_sel),</div><div class="line">                                                      std::forward&lt;Pred&gt;(pred))) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a0e164e3da2482c98fa0d7dd87b25b77a">seq_traits&lt;result_v&gt;::const_pointer</a> {</div><div class="line">            <span class="comment">// Init iterators on first call</span></div><div class="line">            <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                init();</div><div class="line">            }</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a0e164e3da2482c98fa0d7dd87b25b77a">seq_traits&lt;result_v&gt;::const_pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (icurr_ != iendr_) {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#acd4bad5382d0253647e7df4257fe6c5a">seq_traits&lt;result_v&gt;::const_reference</a> robj = *icurr_;</div><div class="line">                pobj = std::addressof(robj);</div><div class="line">                ++icurr_;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    InnerSeq inner_seq_;                <span class="comment">// Inner sequence whose elements to group with outer elements with matching keys</span></div><div class="line">    OuterKeySelector outer_key_sel_;    <span class="comment">// Selector to get keys from elements in the outer sequence</span></div><div class="line">    InnerKeySelector inner_key_sel_;    <span class="comment">// Selector to get keys from elements in the inner sequence</span></div><div class="line">    ResultSelector result_sel_;         <span class="comment">// Selector to convert groups into final results</span></div><div class="line">    Pred pred_;                         <span class="comment">// Predicate used to compare keys</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    group_join_impl(InnerSeq&amp;&amp; inner_seq,</div><div class="line">                    OuterKeySelector&amp;&amp; outer_key_sel,</div><div class="line">                    InnerKeySelector&amp;&amp; inner_key_sel,</div><div class="line">                    ResultSelector&amp;&amp; result_sel,</div><div class="line">                    Pred&amp;&amp; pred)</div><div class="line">        : inner_seq_(std::forward&lt;InnerSeq&gt;(inner_seq)),</div><div class="line">          outer_key_sel_(std::forward&lt;OuterKeySelector&gt;(outer_key_sel)),</div><div class="line">          inner_key_sel_(std::forward&lt;InnerKeySelector&gt;(inner_key_sel)),</div><div class="line">          result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)),</div><div class="line">          pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    group_join_impl(<span class="keyword">const</span> group_join_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    group_join_impl(group_join_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    group_join_impl&amp; operator=(<span class="keyword">const</span> group_join_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    group_join_impl&amp; operator=(group_join_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OuterSeq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(OuterSeq&amp;&amp; outer_seq)</div><div class="line">        -&gt; enumerable&lt;typename seq_traits&lt;typename next_impl&lt;OuterSeq&gt;::result_v&gt;::const_value_type&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;OuterSeq&gt;(std::forward&lt;OuterSeq&gt;(outer_seq),</div><div class="line">                                   std::forward&lt;InnerSeq&gt;(inner_seq_),</div><div class="line">                                   std::forward&lt;OuterKeySelector&gt;(outer_key_sel_),</div><div class="line">                                   std::forward&lt;InnerKeySelector&gt;(inner_key_sel_),</div><div class="line">                                   std::forward&lt;ResultSelector&gt;(result_sel_),</div><div class="line">                                   std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq2, <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>intersect_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that performs intersection</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Vector storing pointers to the elements of second sequence.</span></div><div class="line">        <span class="keyword">using</span> seq2_element_v        = std::vector&lt;typename seq_traits&lt;Seq2&gt;::pointer&gt;;</div><div class="line"></div><div class="line">        <span class="comment">// Type of iterators for the sequences.</span></div><div class="line">        <span class="keyword">using</span> first_iterator_type   = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq1&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Information about intersection. Shared among delegates through smart_ptr.</span></div><div class="line">        <span class="keyword">class </span>intersect_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            Seq1 seq1_;                     <span class="comment">// First sequence to intersect.</span></div><div class="line">            first_iterator_type iend1_;     <span class="comment">// Iterator pointing at end of first sequence.</span></div><div class="line">            Seq2 seq2_;                     <span class="comment">// Second sequence to intersect.</span></div><div class="line">            deref_cmp&lt;Pred&gt; pred_;          <span class="comment">// Predicate used to sort and search through v_in_seq2_.</span></div><div class="line">            seq2_element_v v_in_seq2_;      <span class="comment">// Vector of elements from second sequence.</span></div><div class="line">            <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;      <span class="comment">// Whether v_in_seq2_ has been initialized.</span></div><div class="line"></div><div class="line">            <span class="keywordtype">void</span> init() {</div><div class="line">                <span class="comment">// Add all elements from second sequence to a vector and sort it.</span></div><div class="line">                <a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(v_in_seq2_, seq2_);</div><div class="line">                <span class="keyword">auto</span> icur2 = std::begin(seq2_);</div><div class="line">                <span class="keyword">auto</span> iend2 = std::end(seq2_);</div><div class="line">                <span class="keywordflow">for</span> (; icur2 != iend2; ++icur2) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq2&gt;::reference</a> robjtmp = *icur2;</div><div class="line">                    v_in_seq2_.emplace_back(std::addressof(robjtmp));</div><div class="line">                }</div><div class="line">                std::sort(v_in_seq2_.begin(), v_in_seq2_.end(), pred_);</div><div class="line">                init_called_ = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            intersect_info(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">                : seq1_(std::forward&lt;Seq1&gt;(seq1)),</div><div class="line">                  iend1_(std::end(seq1_)),</div><div class="line">                  seq2_(std::forward&lt;Seq2&gt;(seq2)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Not copyable/movable, stored in a shared_ptr</span></div><div class="line">            intersect_info(<span class="keyword">const</span> intersect_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            intersect_info&amp; operator=(<span class="keyword">const</span> intersect_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            first_iterator_type first_begin() {</div><div class="line">                <span class="keywordflow">return</span> std::begin(seq1_);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> is_in_seq2(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq1&gt;::pointer</a> pobj) {</div><div class="line">                <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                    init();</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> std::binary_search(v_in_seq2_.cbegin(), v_in_seq2_.cend(), pobj, pred_);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Returns next element that is both in first and second sequence or nullptr when done</span></div><div class="line">            <span class="keyword">auto</span> get_next(first_iterator_type&amp; icur1) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq1&gt;::pointer</a> {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq1&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">                <span class="keywordflow">for</span> (; pobj == <span class="keyword">nullptr</span> &amp;&amp; icur1 != iend1_; ++icur1) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq1&gt;::reference</a> robjtmp = *icur1;</div><div class="line">                    <span class="keyword">auto</span> pobjtmp = std::addressof(robjtmp);</div><div class="line">                    <span class="keywordflow">if</span> (is_in_seq2(pobjtmp)) {</div><div class="line">                        pobj = pobjtmp;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> pobj;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> intersect_info_sp = std::shared_ptr&lt;intersect_info&gt;;</div><div class="line"></div><div class="line">        intersect_info_sp spint_info_;      <span class="comment">// Intersection information.</span></div><div class="line">        first_iterator_type icur_;          <span class="comment">// Current position in first sequence.</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">            : spint_info_(std::make_shared&lt;intersect_info&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                                                           std::forward&lt;Seq2&gt;(seq2),</div><div class="line">                                                           std::forward&lt;Pred&gt;(pred))),</div><div class="line">              icur_(spint_info_-&gt;first_begin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; decltype(spint_info_-&gt;get_next(icur_)) {</div><div class="line">            <span class="keywordflow">return</span> spint_info_-&gt;get_next(icur_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Seq2 seq2_;     <span class="comment">// Second sequence to intersect.</span></div><div class="line">    Pred pred_;     <span class="comment">// Predicate used to compare elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    intersect_impl(Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">        : seq2_(std::forward&lt;Seq2&gt;(seq2)),</div><div class="line">          pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    intersect_impl(<span class="keyword">const</span> intersect_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    intersect_impl(intersect_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    intersect_impl&amp; operator=(<span class="keyword">const</span> intersect_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    intersect_impl&amp; operator=(intersect_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq1&amp;&amp; seq1)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq1&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq1&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                               std::forward&lt;Seq2&gt;(seq2_),</div><div class="line">                               std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InnerSeq,</div><div class="line">         <span class="keyword">typename</span> OuterKeySelector,</div><div class="line">         <span class="keyword">typename</span> InnerKeySelector,</div><div class="line">         <span class="keyword">typename</span> ResultSelector,</div><div class="line">         <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>join_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that performs join</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OuterSeq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// Key returned by key selectors.</span></div><div class="line">        <span class="keyword">using</span> key               = decltype(std::declval&lt;OuterKeySelector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;OuterSeq&gt;::reference</a>&gt;()));</div><div class="line"></div><div class="line">        <span class="comment">// Group of pointers to elements from the inner sequence that share a common key.</span></div><div class="line">        <span class="keyword">using</span> inner_element_v   = std::vector&lt;typename seq_traits&lt;InnerSeq&gt;::pointer&gt;;</div><div class="line">    </div><div class="line">        <span class="comment">// Result returned by result selector.</span></div><div class="line">        <span class="keyword">using</span> result            = decltype(std::declval&lt;ResultSelector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;OuterSeq&gt;::reference</a>&gt;(),</div><div class="line">                                                                          std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;InnerSeq&gt;::reference</a>&gt;()));</div><div class="line"></div><div class="line">        <span class="comment">// Vector of results returned by this next delegate.</span></div><div class="line">        <span class="keyword">using</span> result_v          = std::vector&lt;typename std::decay&lt;result&gt;::type&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Bean storing join information. Shared among delegates in a shared_ptr.</span></div><div class="line">        <span class="keyword">class </span>join_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            OuterSeq outer_seq_;                <span class="comment">// Outer sequence.</span></div><div class="line">            InnerSeq inner_seq_;                <span class="comment">// Inner sequence to join with outer sequence.</span></div><div class="line">            OuterKeySelector outer_key_sel_;    <span class="comment">// Key selector for outer sequence.</span></div><div class="line">            InnerKeySelector inner_key_sel_;    <span class="comment">// Key selector for inner sequence.</span></div><div class="line">            ResultSelector result_sel_;         <span class="comment">// Selector converting joined elements into final results.</span></div><div class="line">            Pred pred_;                         <span class="comment">// Predicate used to compare keys.</span></div><div class="line">            result_v results_;                  <span class="comment">// Vector of final results.</span></div><div class="line">            <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;          <span class="comment">// Whether results_ has been initialized.</span></div><div class="line"></div><div class="line">            <span class="keywordtype">void</span> init() {</div><div class="line">                <span class="comment">// Build map of groups of elements from inner sequence.</span></div><div class="line">                <span class="keyword">using</span> groups_m = std::map&lt;typename std::decay&lt;key&gt;::type, inner_element_v, proxy_cmp&lt;Pred&gt;&gt;;</div><div class="line">                groups_m keyed_inner_elems{proxy_cmp&lt;Pred&gt;(pred_)};</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; inner_elem : inner_seq_) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;InnerSeq&gt;::reference</a> robj = inner_elem;</div><div class="line">                    keyed_inner_elems[inner_key_sel_(inner_elem)].emplace_back(std::addressof(robj));</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// Iterate outer sequence and build final results by joining the elements with</span></div><div class="line">                <span class="comment">// those in the groups we built earlier.</span></div><div class="line">                <a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(results_, inner_seq_);</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> iendki = keyed_inner_elems.end();</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; outer_elem : outer_seq_) {</div><div class="line">                    <span class="keyword">const</span> key outer_key = outer_key_sel_(outer_elem);</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> icurki = keyed_inner_elems.find(outer_key);</div><div class="line">                    <span class="keywordflow">if</span> (icurki != iendki) {</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keyword">auto</span>* pinner_elem : icurki-&gt;second) {</div><div class="line">                            results_.emplace_back(result_sel_(outer_elem, *pinner_elem));</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line"></div><div class="line">                init_called_ = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            join_info(OuterSeq&amp;&amp; outer_seq, InnerSeq&amp;&amp; inner_seq,</div><div class="line">                      OuterKeySelector&amp;&amp; outer_key_sel, InnerKeySelector&amp;&amp; inner_key_sel,</div><div class="line">                      ResultSelector&amp;&amp; result_sel, Pred&amp;&amp; pred)</div><div class="line">                : outer_seq_(std::forward&lt;OuterSeq&gt;(outer_seq)),</div><div class="line">                  inner_seq_(std::forward&lt;InnerSeq&gt;(inner_seq)),</div><div class="line">                  outer_key_sel_(std::forward&lt;OuterKeySelector&gt;(outer_key_sel)),</div><div class="line">                  inner_key_sel_(std::forward&lt;InnerKeySelector&gt;(inner_key_sel)),</div><div class="line">                  result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Not copyable/movable, stored in a shared_ptr</span></div><div class="line">            join_info(<span class="keyword">const</span> join_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            join_info&amp; operator=(<span class="keyword">const</span> join_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            <span class="keyword">const</span> result_v&amp; get_results() {</div><div class="line">                <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                    init();</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> results_;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> join_info_sp = std::shared_ptr&lt;join_info&gt;;</div><div class="line"></div><div class="line">        join_info_sp spjoin_info_;                  <span class="comment">// Information about joined elements and results</span></div><div class="line">        <span class="keyword">typename</span> result_v::const_iterator icurr_{}; <span class="comment">// Iterator pointing at current result.</span></div><div class="line">        <span class="keyword">typename</span> result_v::const_iterator iendr_{}; <span class="comment">// Iterator pointing at end of result vector.</span></div><div class="line">        <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;                  <span class="comment">// Whether icurr_/iendr_ have been initialized.</span></div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> init() {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; results = spjoin_info_-&gt;get_results();</div><div class="line">            icurr_ = std::begin(results);</div><div class="line">            iendr_ = std::end(results);</div><div class="line">            init_called_ = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(OuterSeq&amp;&amp; outer_seq, InnerSeq&amp;&amp; inner_seq,</div><div class="line">                  OuterKeySelector&amp;&amp; outer_key_sel, InnerKeySelector&amp;&amp; inner_key_sel,</div><div class="line">                  ResultSelector&amp;&amp; result_sel, Pred&amp;&amp; pred)</div><div class="line">            : spjoin_info_(std::make_shared&lt;join_info&gt;(std::forward&lt;OuterSeq&gt;(outer_seq),</div><div class="line">                                                       std::forward&lt;InnerSeq&gt;(inner_seq),</div><div class="line">                                                       std::forward&lt;OuterKeySelector&gt;(outer_key_sel),</div><div class="line">                                                       std::forward&lt;InnerKeySelector&gt;(inner_key_sel),</div><div class="line">                                                       std::forward&lt;ResultSelector&gt;(result_sel),</div><div class="line">                                                       std::forward&lt;Pred&gt;(pred))) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a0e164e3da2482c98fa0d7dd87b25b77a">seq_traits&lt;result_v&gt;::const_pointer</a> {</div><div class="line">            <span class="comment">// Init iterators on first call</span></div><div class="line">            <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                init();</div><div class="line">            }</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a0e164e3da2482c98fa0d7dd87b25b77a">seq_traits&lt;result_v&gt;::const_pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (icurr_ != iendr_) {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#acd4bad5382d0253647e7df4257fe6c5a">seq_traits&lt;result_v&gt;::const_reference</a> robj = *icurr_;</div><div class="line">                pobj = std::addressof(robj);</div><div class="line">                ++icurr_;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    InnerSeq inner_seq_;                <span class="comment">// Inner sequence to join.</span></div><div class="line">    OuterKeySelector outer_key_sel_;    <span class="comment">// Fetches keys for elements of outer sequence.</span></div><div class="line">    InnerKeySelector inner_key_sel_;    <span class="comment">// Fetches keys for elements of inner sequence.</span></div><div class="line">    ResultSelector result_sel_;         <span class="comment">// Creates results from joined elements.</span></div><div class="line">    Pred pred_;                         <span class="comment">// Predicate to compare keys.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    join_impl(InnerSeq&amp;&amp; inner_seq,</div><div class="line">              OuterKeySelector&amp;&amp; outer_key_sel,</div><div class="line">              InnerKeySelector&amp;&amp; inner_key_sel,</div><div class="line">              ResultSelector&amp;&amp; result_sel,</div><div class="line">              Pred&amp;&amp; pred)</div><div class="line">        : inner_seq_(std::forward&lt;InnerSeq&gt;(inner_seq)),</div><div class="line">          outer_key_sel_(std::forward&lt;OuterKeySelector&gt;(outer_key_sel)),</div><div class="line">          inner_key_sel_(std::forward&lt;InnerKeySelector&gt;(inner_key_sel)),</div><div class="line">          result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)),</div><div class="line">          pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    join_impl(<span class="keyword">const</span> join_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    join_impl(join_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    join_impl&amp; operator=(<span class="keyword">const</span> join_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    join_impl&amp; operator=(join_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OuterSeq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(OuterSeq&amp;&amp; outer_seq)</div><div class="line">        -&gt; enumerable&lt;typename seq_traits&lt;typename next_impl&lt;OuterSeq&gt;::result_v&gt;::const_value_type&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;OuterSeq&gt;(std::forward&lt;OuterSeq&gt;(outer_seq),</div><div class="line">                                   std::forward&lt;InnerSeq&gt;(inner_seq_),</div><div class="line">                                   std::forward&lt;OuterKeySelector&gt;(outer_key_sel_),</div><div class="line">                                   std::forward&lt;InnerKeySelector&gt;(inner_key_sel_),</div><div class="line">                                   std::forward&lt;ResultSelector&gt;(result_sel_),</div><div class="line">                                   std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>last_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// If we have bidi iterators, we can simply use rbegin</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::bidirectional_iterator_tag) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> ricur = seq.rbegin();</div><div class="line">        <span class="keywordflow">if</span> (ricur == seq.rend()) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *ricur;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise we&#39;ll have to be creative</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::input_iterator_tag) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (icur == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        decltype(icur) iprev;</div><div class="line">        <span class="keywordflow">while</span> (icur != iend) {</div><div class="line">            iprev = icur;</div><div class="line">            ++icur;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *iprev;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq),</div><div class="line">                    <span class="keyword">typename</span> std::iterator_traits&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>&gt;::iterator_category());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>last_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// If we have bidi iterators, we can simply use rbegin</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::bidirectional_iterator_tag) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> ricur = seq.rbegin();</div><div class="line">        <span class="keyword">auto</span> riend = seq.rend();</div><div class="line">        <span class="keywordflow">if</span> (ricur == riend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> rifound = std::find_if(ricur, riend, pred_);</div><div class="line">        <span class="keywordflow">if</span> (rifound == riend) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *rifound;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise we&#39;ll have to be creative</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::input_iterator_tag) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (icur == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> ifound = iend;</div><div class="line">        <span class="keywordflow">while</span> (icur != iend) {</div><div class="line">            <span class="keywordflow">if</span> (pred_(*icur)) {</div><div class="line">                ifound = icur;</div><div class="line">            }</div><div class="line">            ++icur;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (ifound == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *ifound;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> last_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq),</div><div class="line">                    <span class="keyword">typename</span> std::iterator_traits&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>&gt;::iterator_category());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>last_or_default_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// If we have bidi iterators, we can simply use rbegin</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::bidirectional_iterator_tag) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> ricur = seq.rbegin();</div><div class="line">        <span class="keywordflow">return</span> ricur != seq.rend() ? *ricur</div><div class="line">                                   : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise we&#39;ll have to be creative</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::input_iterator_tag) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keyword">auto</span> iprev = iend;</div><div class="line">        <span class="keywordflow">while</span> (icur != iend) {</div><div class="line">            iprev = icur;</div><div class="line">            ++icur;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> iprev != iend ? *iprev</div><div class="line">                             : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq),</div><div class="line">                    <span class="keyword">typename</span> std::iterator_traits&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>&gt;::iterator_category());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>last_or_default_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy</span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// If we have bidi iterators, we can simply use rbegin</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::bidirectional_iterator_tag) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> riend = seq.rend();</div><div class="line">        <span class="keyword">auto</span> rifound = std::find_if(seq.rbegin(), riend, pred_);</div><div class="line">        <span class="keywordflow">return</span> rifound != riend ? *rifound</div><div class="line">                                : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise we&#39;ll have to be creative</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::input_iterator_tag) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keyword">auto</span> ifound = iend;</div><div class="line">        <span class="keywordflow">while</span> (icur != iend) {</div><div class="line">            <span class="keywordflow">if</span> (pred_(*icur)) {</div><div class="line">                ifound = icur;</div><div class="line">            }</div><div class="line">            ++icur;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> ifound != iend ? *ifound</div><div class="line">                              : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> last_or_default_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq),</div><div class="line">                    <span class="keyword">typename</span> std::iterator_traits&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>&gt;::iterator_category());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>max_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keyword">auto</span> imax = std::max_element(std::begin(seq), iend);</div><div class="line">        <span class="keywordflow">if</span> (imax == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *imax;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Selector&gt;</div><div class="line"><span class="keyword">class </span>max_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Selector&amp; sel_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> max_impl_1(<span class="keyword">const</span> Selector&amp; sel)</div><div class="line">        : sel_(sel) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> std::decay&lt;decltype(sel_(*std::begin(seq)))&gt;::type {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (icur == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> max_val = sel_(*icur);</div><div class="line">        <span class="keywordflow">while</span> (++icur != iend) {</div><div class="line">            max_val = <a class="code" href="group__linq__op__max.html#ga2debe504c6d71aad9d4b0466d46fe536">std::max</a>(max_val, sel_(*icur));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> max_val;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>min_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keyword">auto</span> imin = std::min_element(std::begin(seq), iend);</div><div class="line">        <span class="keywordflow">if</span> (imin == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *imin;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Selector&gt;</div><div class="line"><span class="keyword">class </span>min_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Selector&amp; sel_;   <span class="comment">// Selector used to fetch values from sequence elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> min_impl_1(<span class="keyword">const</span> Selector&amp; sel)</div><div class="line">        : sel_(sel) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> std::decay&lt;decltype(sel_(*std::begin(seq)))&gt;::type {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (icur == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> min_val = sel_(*icur);</div><div class="line">        <span class="keywordflow">while</span> (++icur != iend) {</div><div class="line">            min_val = <a class="code" href="group__linq__op__min.html#gaa01a358923d77a5f0f80b89826454df2">std::min</a>(min_val, sel_(*icur));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> min_val;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>none_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> none_impl(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keywordflow">return</span> std::none_of(std::begin(seq), std::end(seq), pred_);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeySelector,</div><div class="line">         <span class="keyword">typename</span> Pred,</div><div class="line">         <span class="keywordtype">bool</span> Descending,</div><div class="line">         <span class="keywordtype">int</span> _LessValue = Descending ? 1 : -1&gt;</div><div class="line"><span class="keyword">class </span>order_by_comparator</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    KeySelector key_sel_;   <span class="comment">// Key selector used to fetch keys from elements.</span></div><div class="line">    Pred pred_;             <span class="comment">// Predicate used to compare keys.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    order_by_comparator(KeySelector&amp;&amp; key_sel, Pred&amp;&amp; pred)</div><div class="line">        : key_sel_(std::forward&lt;KeySelector&gt;(key_sel)), pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Cannot copy/move, stored in a unique_ptr</span></div><div class="line">    order_by_comparator(<span class="keyword">const</span> order_by_comparator&amp;) = <span class="keyword">delete</span>;</div><div class="line">    order_by_comparator&amp; operator=(<span class="keyword">const</span> order_by_comparator&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Compares two values, returning relative position of the two in an ordered sequence.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div><div class="line">    <span class="keywordtype">int</span> operator()(T1&amp;&amp; left, T2&amp;&amp; right)<span class="keyword"> const </span>{</div><div class="line">        decltype(key_sel_(left)) leftk = key_sel_(left);</div><div class="line">        decltype(key_sel_(right)) rightk = key_sel_(right);</div><div class="line">        <span class="keywordtype">int</span> cmp;</div><div class="line">        <span class="keywordflow">if</span> (pred_(leftk, rightk)) {</div><div class="line">            cmp = _LessValue;</div><div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pred_(rightk, leftk)) {</div><div class="line">            cmp = -_LessValue;</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <span class="comment">// Keys are equal.</span></div><div class="line">            cmp = 0;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> cmp;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cmp1, <span class="keyword">typename</span> Cmp2&gt;</div><div class="line"><span class="keyword">class </span>dual_order_by_comparator</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::unique_ptr&lt;Cmp1&gt; upcmp1_;</div><div class="line">    std::unique_ptr&lt;Cmp2&gt; upcmp2_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    dual_order_by_comparator(std::unique_ptr&lt;Cmp1&gt;&amp;&amp; upcmp1, std::unique_ptr&lt;Cmp2&gt;&amp;&amp; upcmp2)</div><div class="line">        : upcmp1_(std::move(upcmp1)), upcmp2_(std::move(upcmp2)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Cannot copy/move, stored in a unique_ptr</span></div><div class="line">    dual_order_by_comparator(<span class="keyword">const</span> dual_order_by_comparator&amp;) = <span class="keyword">delete</span>;</div><div class="line">    dual_order_by_comparator&amp; operator=(<span class="keyword">const</span> dual_order_by_comparator&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Compares two values by calling first then second comparator.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div><div class="line">    <span class="keywordtype">int</span> operator()(T1&amp;&amp; left, T2&amp;&amp; right)<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordtype">int</span> cmp = (*upcmp1_)(left, right);</div><div class="line">        <span class="keywordflow">if</span> (cmp == 0) {</div><div class="line">            cmp = (*upcmp2_)(left, right);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> cmp;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Forward declaration to declare friendship</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cmp&gt; <span class="keyword">class </span>order_by_impl;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> Cmp&gt;</div><div class="line"><span class="keyword">class </span>order_by_impl_with_seq</div><div class="line">{</div><div class="line">    <span class="comment">// We need this friendship so that it can &quot;steal&quot; our internals.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">friend</span> <span class="keyword">class </span>order_by_impl;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Seq seq_;                                                   <span class="comment">// Sequence we&#39;re ordering.</span></div><div class="line">    std::unique_ptr&lt;Cmp&gt; upcmp_;                                <span class="comment">// Comparator used to order a sequence.</span></div><div class="line">    <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt; enum_;     <span class="comment">// Enumerator of ordered elements.</span></div><div class="line">    <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;                                  <span class="comment">// Whether enum_ has been initialized.</span></div><div class="line"></div><div class="line">    <span class="comment">// Called to initialize enum_ before using it.</span></div><div class="line">    <span class="keywordtype">void</span> init() {</div><div class="line">        std::vector&lt;typename seq_traits&lt;Seq&gt;::pointer&gt; ordered;</div><div class="line">        <a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(ordered, seq_);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; elem : seq_) {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a> robj = elem;</div><div class="line">            ordered.push_back(std::addressof(robj));</div><div class="line">        }</div><div class="line">        std::stable_sort(ordered.begin(),</div><div class="line">                         ordered.end(),</div><div class="line">                         [<span class="keyword">this</span>](<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pleft,</div><div class="line">                                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pright) {</div><div class="line">            <span class="keywordflow">return</span> (*upcmp_)(*pleft, *pright) &lt; 0;</div><div class="line">        });</div><div class="line">        <span class="keyword">const</span> std::size_t num_ordered = ordered.size();</div><div class="line">        enum_ = { make_deref_next_impl(std::move(ordered)),</div><div class="line">                  [num_ordered]() -&gt; std::size_t { <span class="keywordflow">return</span> num_ordered; } };</div><div class="line">        init_called_ = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Type of iterators used for the ordered sequence.</span></div><div class="line">    <span class="keyword">using</span> iterator          = <span class="keyword">typename</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;::iterator;</div><div class="line">    <span class="keyword">using</span> const_iterator    = <span class="keyword">typename</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;::const_iterator;</div><div class="line"></div><div class="line">    <span class="comment">// Constructor called by the impl without sequence.</span></div><div class="line">    order_by_impl_with_seq(Seq&amp;&amp; seq, std::unique_ptr&lt;Cmp&gt;&amp;&amp; upcmp)</div><div class="line">        : seq_(std::forward&lt;Seq&gt;(seq)), upcmp_(std::move(upcmp)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    order_by_impl_with_seq(<span class="keyword">const</span> order_by_impl_with_seq&amp;) = <span class="keyword">delete</span>;</div><div class="line">    order_by_impl_with_seq(order_by_impl_with_seq&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    order_by_impl_with_seq&amp; operator=(<span class="keyword">const</span> order_by_impl_with_seq&amp;) = <span class="keyword">delete</span>;</div><div class="line">    order_by_impl_with_seq&amp; operator=(order_by_impl_with_seq&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Support for ordered sequence.</span></div><div class="line">    iterator begin()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">            <span class="keyword">const_cast&lt;</span>order_by_impl_with_seq&lt;Seq, Cmp&gt;*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;init();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> enum_.begin();</div><div class="line">    }</div><div class="line">    iterator end()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">            <span class="keyword">const_cast&lt;</span>order_by_impl_with_seq&lt;Seq, Cmp&gt;*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;init();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> enum_.end();</div><div class="line">    }</div><div class="line">    iterator cbegin()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> begin();</div><div class="line">    }</div><div class="line">    iterator cend()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">return</span> end();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Support for sequence size (a bit like the enumerable API)</span></div><div class="line">    <span class="keywordtype">bool</span> has_fast_size()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">            <span class="keyword">const_cast&lt;</span>order_by_impl_with_seq&lt;Seq, Cmp&gt;*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;init();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> enum_.has_fast_size();</div><div class="line">    }</div><div class="line">    std::size_t size()<span class="keyword"> const </span>{</div><div class="line">        <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">            <span class="keyword">const_cast&lt;</span>order_by_impl_with_seq&lt;Seq, Cmp&gt;*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;init();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> enum_.size();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cmp&gt;</div><div class="line"><span class="keyword">class </span>order_by_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::unique_ptr&lt;Cmp&gt; upcmp_;    <span class="comment">// Comparator used to order a sequence.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> order_by_impl(std::unique_ptr&lt;Cmp&gt;&amp;&amp; upcmp)</div><div class="line">        : upcmp_(std::move(upcmp)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable by not copyable</span></div><div class="line">    order_by_impl(<span class="keyword">const</span> order_by_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    order_by_impl(order_by_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    order_by_impl&amp; operator=(<span class="keyword">const</span> order_by_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    order_by_impl&amp; operator=(order_by_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="comment">// When applied to a sequence, produces a different object.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; order_by_impl_with_seq&lt;Seq, Cmp&gt; {</div><div class="line">        <span class="keywordflow">return</span> order_by_impl_with_seq&lt;Seq, Cmp&gt;(std::forward&lt;Seq&gt;(seq), std::move(upcmp_));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// When applied to an impl with sequence, merges the two and chains the comparators.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ImplSeq, <span class="keyword">typename</span> ImplCmp&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(order_by_impl_with_seq&lt;ImplSeq, ImplCmp&gt;&amp;&amp; impl)</div><div class="line">        -&gt; order_by_impl_with_seq&lt;ImplSeq, dual_order_by_comparator&lt;ImplCmp, Cmp&gt;&gt;</div><div class="line">    {</div><div class="line">        <span class="keyword">using</span> dual_comparator = dual_order_by_comparator&lt;ImplCmp, Cmp&gt;;</div><div class="line">        <span class="keyword">auto</span> new_upcmp = detail::make_unique&lt;dual_comparator&gt;(std::move(impl.upcmp_), std::move(upcmp_));</div><div class="line">        <span class="keywordflow">return</span> order_by_impl_with_seq&lt;ImplSeq, dual_comparator&gt;(std::forward&lt;ImplSeq&gt;(impl.seq_), std::move(new_upcmp));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>reverse_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// next impl when we can use reverse iterators</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl_fast</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Iterator used to go backward in sequence.</span></div><div class="line">        <span class="keyword">using</span> reverse_iterator = <span class="keyword">typename</span> std::decay&lt;decltype(std::declval&lt;Seq&gt;().rbegin())&gt;::type;</div><div class="line"></div><div class="line">        <span class="comment">// Bean containing info shared among delegates</span></div><div class="line">        <span class="keyword">struct </span>reverse_info {</div><div class="line">            Seq seq_;                   <span class="comment">// Sequence we&#39;re iterating.</span></div><div class="line">            reverse_iterator irend_;    <span class="comment">// End of reversed seq_.</span></div><div class="line"></div><div class="line">            <span class="keyword">explicit</span> reverse_info(Seq&amp;&amp; seq)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  irend_(seq_.rend()) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr.</span></div><div class="line">            reverse_info(<span class="keyword">const</span> reverse_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            reverse_info&amp; operator=(<span class="keyword">const</span> reverse_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> reverse_info_sp = std::shared_ptr&lt;reverse_info&gt;;</div><div class="line"></div><div class="line">        reverse_info_sp spinfo_;    <span class="comment">// Shared info with sequence.</span></div><div class="line">        reverse_iterator ircur_;    <span class="comment">// Current point in reverse sequence.</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl_fast(Seq&amp;&amp; seq)</div><div class="line">            : spinfo_(std::make_shared&lt;reverse_info&gt;(std::forward&lt;Seq&gt;(seq))),</div><div class="line">              ircur_(spinfo_-&gt;seq_.rbegin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (ircur_ != spinfo_-&gt;irend_) {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a> robj = *ircur_;</div><div class="line">                pobj = std::addressof(robj);</div><div class="line">                ++ircur_;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// next impl when we don&#39;t have reverse iterators natively</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl_slow</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Vector storing pointers of elements from sequence.</span></div><div class="line">        <span class="keyword">using</span> pelems_v                  = std::vector&lt;typename seq_traits&lt;Seq&gt;::pointer&gt;;</div><div class="line">        <span class="keyword">using</span> pelems_v_reverse_iterator = <span class="keyword">typename</span> pelems_v::reverse_iterator;</div><div class="line"></div><div class="line">        <span class="comment">// Bean containing info shared among delegates</span></div><div class="line">        <span class="keyword">struct </span>reverse_info {</div><div class="line">            Seq seq_;                           <span class="comment">// Sequence containing the elements.</span></div><div class="line">            pelems_v vpelems_;                  <span class="comment">// Vector of pointers to the elements.</span></div><div class="line">            pelems_v_reverse_iterator virend_;  <span class="comment">// Iterator pointing at end of vpelems_.</span></div><div class="line"></div><div class="line">            <span class="keyword">explicit</span> reverse_info(Seq&amp;&amp; seq)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq))</div><div class="line">            {</div><div class="line">                <span class="comment">// Build vector of pointers to sequence elements.</span></div><div class="line">                <a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(vpelems_, seq_);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; elem : seq_) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a> robj = elem;</div><div class="line">                    vpelems_.push_back(std::addressof(robj));</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">// Init end iterator.</span></div><div class="line">                virend_ = vpelems_.rend();</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr.</span></div><div class="line">            reverse_info(<span class="keyword">const</span> reverse_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            reverse_info&amp; operator=(<span class="keyword">const</span> reverse_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> reverse_info_sp = std::shared_ptr&lt;reverse_info&gt;;</div><div class="line"></div><div class="line">        reverse_info_sp spinfo_;            <span class="comment">// Bean storing sequence and vector of pointers.</span></div><div class="line">        pelems_v_reverse_iterator vircur_;  <span class="comment">// Iterator pointing at current pointer to element.</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl_slow(Seq&amp;&amp; seq)</div><div class="line">            : spinfo_(std::make_shared&lt;reverse_info&gt;(std::forward&lt;Seq&gt;(seq))),</div><div class="line">              vircur_(spinfo_-&gt;vpelems_.rbegin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (vircur_ != spinfo_-&gt;virend_) {</div><div class="line">                pobj = *vircur_;</div><div class="line">                ++vircur_;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// To be able to build a proper size delegate</span></div><div class="line">        std::size_t size()<span class="keyword"> const </span>{</div><div class="line">            <span class="keywordflow">return</span> spinfo_-&gt;vpelems_.size();</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// If we have bidi iterators, we can simply use rbegin</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::bidirectional_iterator_tag)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> siz = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq);</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;(next_impl_fast&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                                                                siz);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise we&#39;ll have to be creative</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> impl(Seq&amp;&amp; seq, std::input_iterator_tag)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        next_impl_slow&lt;Seq&gt; next_impl(std::forward&lt;Seq&gt;(seq));</div><div class="line">        <span class="keyword">const</span> std::size_t size = next_impl.size();</div><div class="line">        <span class="keyword">auto</span> siz = [size]() -&gt; std::size_t { <span class="keywordflow">return</span> size; };</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;(std::move(next_impl),</div><div class="line">                                                                siz);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> impl(std::forward&lt;Seq&gt;(seq),</div><div class="line">                    <span class="keyword">typename</span> std::iterator_traits&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>&gt;::iterator_category());</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Selector&gt;</div><div class="line"><span class="keyword">class </span>select_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Next delegate implementation for select operator</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> CU, <span class="keyword">typename</span> RU&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Iterator used by the sequence.</span></div><div class="line">        <span class="keyword">using</span> iterator_type             = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Containers storing transformed elements.</span></div><div class="line">        <span class="keyword">using</span> transformed_v             = std::vector&lt;RU&gt;;</div><div class="line">        <span class="keyword">using</span> transformed_l             = std::forward_list&lt;RU&gt;;</div><div class="line">        <span class="keyword">using</span> transformed_l_iterator    = <span class="keyword">typename</span> transformed_l::iterator;</div><div class="line"></div><div class="line">        <span class="comment">// Bean storing info about elements. Shared among delegates.</span></div><div class="line">        <span class="keyword">struct </span>select_info {</div><div class="line">            Seq seq_;                       <span class="comment">// Sequence being transformed.</span></div><div class="line">            iterator_type icur_;            <span class="comment">// Iterator pointing at current element in seq_.</span></div><div class="line">            iterator_type iend_;            <span class="comment">// Iterator pointing at end of seq_.</span></div><div class="line">            Selector sel_;                  <span class="comment">// Selector transforming the elements.</span></div><div class="line">            transformed_v vtransformed_;    <span class="comment">// Vector of transformed elements.</span></div><div class="line">            transformed_l ltransformed_;    <span class="comment">// List of transformed elements.</span></div><div class="line">            transformed_l_iterator llast_;  <span class="comment">// Iterator pointing to last element in ltransformed_ (before end()).</span></div><div class="line">            std::size_t lsize_;             <span class="comment">// Number of elements in ltransformed_.</span></div><div class="line">            <span class="keywordtype">bool</span> use_vector_;               <span class="comment">// Whether we use ltransformed_ (false) or vtransformed_ (true).</span></div><div class="line"></div><div class="line">            select_info(Seq&amp;&amp; seq, Selector&amp;&amp; sel)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  icur_(std::begin(seq_)),</div><div class="line">                  iend_(std::end(seq_)),</div><div class="line">                  sel_(std::forward&lt;Selector&gt;(sel)),</div><div class="line">                  vtransformed_(),</div><div class="line">                  ltransformed_(),</div><div class="line">                  llast_(ltransformed_.before_begin()),</div><div class="line">                  lsize_(0),</div><div class="line">                  use_vector_(<a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(vtransformed_, seq_)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            select_info(<span class="keyword">const</span> select_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            select_info&amp; operator=(<span class="keyword">const</span> select_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> get_next_in_vector(std::size_t&amp; vncur) -&gt; CU* {</div><div class="line">                <span class="keywordflow">while</span> (vtransformed_.size() &lt;= vncur &amp;&amp; icur_ != iend_) {</div><div class="line">                    vtransformed_.emplace_back(sel_(*icur_, vtransformed_.size()));</div><div class="line">                    ++icur_;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> vtransformed_.size() &gt; vncur ? std::addressof(vtransformed_[vncur++])</div><div class="line">                                                    : nullptr;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> get_next_in_list(transformed_l_iterator&amp; licur) -&gt; CU* {</div><div class="line">                <span class="keywordflow">while</span> (licur == llast_ &amp;&amp; icur_ != iend_) {</div><div class="line">                    llast_ = ltransformed_.emplace_after(llast_, sel_(*icur_, lsize_++));</div><div class="line">                    ++icur_;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> licur != llast_ ? std::addressof(*++licur)</div><div class="line">                                       : nullptr;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> get_next(std::size_t&amp; vncur, transformed_l_iterator&amp; licur) -&gt; CU* {</div><div class="line">                <span class="keywordflow">return</span> use_vector_ ? get_next_in_vector(vncur)</div><div class="line">                                   : get_next_in_list(licur);</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> select_info_sp = std::shared_ptr&lt;select_info&gt;;</div><div class="line"></div><div class="line">        select_info_sp spinfo_;         <span class="comment">// Shared information about elements.</span></div><div class="line">        std::size_t vncur_;             <span class="comment">// Index of current element (if in vector).</span></div><div class="line">        transformed_l_iterator licur_;  <span class="comment">// Iterator pointing at current element (if in list).</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq&amp;&amp; seq, Selector&amp;&amp; sel)</div><div class="line">            : spinfo_(std::make_shared&lt;select_info&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                    std::forward&lt;Selector&gt;(sel))),</div><div class="line">              vncur_(0),</div><div class="line">              licur_(spinfo_-&gt;ltransformed_.before_begin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; CU* {</div><div class="line">            <span class="keywordflow">return</span> spinfo_-&gt;get_next(vncur_, licur_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Selector sel_;  <span class="comment">// Selector used to transform elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> select_impl(Selector&amp;&amp; sel)</div><div class="line">        : sel_(std::forward&lt;Selector&gt;(sel)) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq,</div><div class="line">             <span class="keyword">typename</span> _SelectorRes = decltype(std::declval&lt;Selector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a>&gt;(), std::declval&lt;std::size_t&gt;())),</div><div class="line">             <span class="keyword">typename</span> _CU = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#aa574bb61aefed9bf9336a7c59c4b9ba4">seq_element_traits&lt;_SelectorRes&gt;::const_value_type</a>,</div><div class="line">             <span class="keyword">typename</span> _RU = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_element_traits&lt;_SelectorRes&gt;::raw_value_type</a>&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; enumerable&lt;_CU&gt; {</div><div class="line">        <span class="keyword">auto</span> siz = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq);</div><div class="line">        <span class="keywordflow">return</span> enumerable&lt;_CU&gt;(next_impl&lt;Seq, _CU, _RU&gt;(std::forward&lt;Seq&gt;(seq), std::forward&lt;Selector&gt;(sel_)),</div><div class="line">                               siz);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Selector&gt;</div><div class="line"><span class="keyword">class </span>select_many_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Next delegate implementation for select_many operator</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> CU, <span class="keyword">typename</span> RU&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Iterator used by the sequence.</span></div><div class="line">        <span class="keyword">using</span> iterator_type             = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// List storing transformed elements.</span></div><div class="line">        <span class="keyword">using</span> transformed_l             = std::forward_list&lt;RU&gt;;</div><div class="line">        <span class="keyword">using</span> transformed_l_iterator    = <span class="keyword">typename</span> transformed_l::iterator;</div><div class="line"></div><div class="line">        <span class="comment">// Bean storing info about elements. Shared among delegates.</span></div><div class="line">        <span class="keyword">struct </span>select_info {</div><div class="line">            Seq seq_;                       <span class="comment">// Sequence being transformed.</span></div><div class="line">            iterator_type icur_;            <span class="comment">// Iterator pointing at current element in seq_.</span></div><div class="line">            std::size_t idx_;               <span class="comment">// Index of current element in seq_.</span></div><div class="line">            iterator_type iend_;            <span class="comment">// Iterator pointing at end of seq_.</span></div><div class="line">            Selector sel_;                  <span class="comment">// Selector transforming the elements.</span></div><div class="line">            transformed_l ltransformed_;    <span class="comment">// List of transformed elements.</span></div><div class="line">            transformed_l_iterator llast_;  <span class="comment">// Iterator pointing to last element in ltransformed_ (before end()).</span></div><div class="line"></div><div class="line">            select_info(Seq&amp;&amp; seq, Selector&amp;&amp; sel)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  icur_(std::begin(seq_)),</div><div class="line">                  idx_(0),</div><div class="line">                  iend_(std::end(seq_)),</div><div class="line">                  sel_(std::forward&lt;Selector&gt;(sel)),</div><div class="line">                  ltransformed_(),</div><div class="line">                  llast_(ltransformed_.before_begin()) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            select_info(<span class="keyword">const</span> select_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            select_info&amp; operator=(<span class="keyword">const</span> select_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> get_next(transformed_l_iterator&amp; licur) -&gt; CU* {</div><div class="line">                <span class="keywordflow">while</span> (licur == llast_ &amp;&amp; icur_ != iend_) {</div><div class="line">                    <span class="keyword">auto</span> new_elements = sel_(*icur_, idx_++);</div><div class="line">                    llast_ = ltransformed_.insert_after(llast_, std::begin(new_elements), std::end(new_elements));</div><div class="line">                    ++icur_;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> licur != llast_ ? std::addressof(*++licur)</div><div class="line">                                       : nullptr;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> select_info_sp = std::shared_ptr&lt;select_info&gt;;</div><div class="line"></div><div class="line">        select_info_sp spinfo_;         <span class="comment">// Shared information about elements.</span></div><div class="line">        transformed_l_iterator licur_;  <span class="comment">// Iterator pointing at current element.</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq&amp;&amp; seq, Selector&amp;&amp; sel)</div><div class="line">            : spinfo_(std::make_shared&lt;select_info&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                    std::forward&lt;Selector&gt;(sel))),</div><div class="line">              licur_(spinfo_-&gt;ltransformed_.before_begin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; CU* {</div><div class="line">            <span class="keywordflow">return</span> spinfo_-&gt;get_next(licur_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Selector sel_;  <span class="comment">// Selector used to transform elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> select_many_impl(Selector&amp;&amp; sel)</div><div class="line">        : sel_(std::forward&lt;Selector&gt;(sel)) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq,</div><div class="line">             <span class="keyword">typename</span> _SelectorSeqRes = decltype(std::declval&lt;Selector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#acd4bad5382d0253647e7df4257fe6c5a">seq_traits&lt;Seq&gt;::const_reference</a>&gt;(), std::declval&lt;std::size_t&gt;())),</div><div class="line">             <span class="keyword">typename</span> _CU = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#aa574bb61aefed9bf9336a7c59c4b9ba4">seq_traits&lt;_SelectorSeqRes&gt;::const_value_type</a>,</div><div class="line">             <span class="keyword">typename</span> _RU = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;_SelectorSeqRes&gt;::raw_value_type</a>&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; enumerable&lt;_CU&gt; {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq, _CU, _RU&gt;(std::forward&lt;Seq&gt;(seq), std::forward&lt;Selector&gt;(sel_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq2&gt;</div><div class="line"><span class="keyword">class </span>sequence_equal_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Seq2&amp; seq2_;  <span class="comment">// Second sequence to compare.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> sequence_equal_impl_1(<span class="keyword">const</span> Seq2&amp; seq2)</div><div class="line">        : seq2_(seq2) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq1&amp;&amp; seq1) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keyword">auto</span> icur1 = std::begin(seq1);</div><div class="line">        <span class="keyword">auto</span> iend1 = std::end(seq1);</div><div class="line">        <span class="keyword">auto</span> icur2 = std::begin(seq2_);</div><div class="line">        <span class="keyword">auto</span> iend2 = std::end(seq2_);</div><div class="line">        <span class="keywordtype">bool</span> is_equal = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">for</span> (; is_equal &amp;&amp; icur1 != iend1 &amp;&amp; icur2 != iend2; ++icur1, ++icur2) {</div><div class="line">            is_equal = *icur1 == *icur2;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> is_equal &amp;&amp; icur1 == iend1 &amp;&amp; icur2 == iend2;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq2, <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>sequence_equal_impl_2</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Seq2&amp; seq2_;  <span class="comment">// Second sequence to compare.</span></div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Equality predicate.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    sequence_equal_impl_2(<span class="keyword">const</span> Seq2&amp; seq2, <span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : seq2_(seq2), pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq1&amp;&amp; seq1) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keyword">auto</span> icur1 = std::begin(seq1);</div><div class="line">        <span class="keyword">auto</span> iend1 = std::end(seq1);</div><div class="line">        <span class="keyword">auto</span> icur2 = std::begin(seq2_);</div><div class="line">        <span class="keyword">auto</span> iend2 = std::end(seq2_);</div><div class="line">        <span class="keywordtype">bool</span> is_equal = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">for</span> (; is_equal &amp;&amp; icur1 != iend1 &amp;&amp; icur2 != iend2; ++icur1, ++icur2) {</div><div class="line">            is_equal = pred_(*icur1, *icur2);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> is_equal &amp;&amp; icur1 == iend1 &amp;&amp; icur2 == iend2;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>single_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> ifirst = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (ifirst == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> inext = ifirst;</div><div class="line">        ++inext;</div><div class="line">        <span class="keywordflow">if</span> (inext != iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *ifirst;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>single_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> single_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; decltype(*std::begin(seq)) {</div><div class="line">        <span class="keyword">auto</span> ibeg = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (ibeg == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> ifound = std::find_if(ibeg, iend, pred_);</div><div class="line">        <span class="keywordflow">if</span> (ifound == iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> inext = ifound;</div><div class="line">        ++inext;</div><div class="line">        <span class="keyword">auto</span> ifoundagain = std::find_if(inext, iend, pred_);</div><div class="line">        <span class="keywordflow">if</span> (ifoundagain != iend) {</div><div class="line">            <a class="code" href="exception_8h.html#a7cdb1dc43a6925148e98027fab96a97e">throw_linq_out_of_range</a>();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> *ifound;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>single_or_default_impl_0</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> icur = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (icur != iend) {</div><div class="line">            <span class="keyword">auto</span> inext = icur;</div><div class="line">            ++inext;</div><div class="line">            <span class="keywordflow">if</span> (inext != iend) {</div><div class="line">                icur = iend;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> icur != iend ? *icur</div><div class="line">                            : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>single_or_default_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Pred&amp; pred_;  <span class="comment">// Predicate to satisfy.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> single_or_default_impl_1(<span class="keyword">const</span> Pred&amp; pred)</div><div class="line">        : pred_(pred) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a> {</div><div class="line">        <span class="keyword">auto</span> iend = std::end(seq);</div><div class="line">        <span class="keyword">auto</span> ifound = std::find_if(std::begin(seq), iend, pred_);</div><div class="line">        <span class="keywordflow">if</span> (ifound != iend) {</div><div class="line">            <span class="keyword">auto</span> inext = ifound;</div><div class="line">            ++inext;</div><div class="line">            <span class="keyword">auto</span> ifoundagain = std::find_if(inext, iend, pred_);</div><div class="line">            <span class="keywordflow">if</span> (ifoundagain != iend) {</div><div class="line">                ifound = iend;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> ifound != iend ? *ifound</div><div class="line">                              : <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>skip_n_pred</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_; <span class="comment">// Number of elements to skip.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> skip_n_pred(std::size_t n)</div><div class="line">        : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(T&amp;&amp;, std::size_t idx) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">        <span class="keywordflow">return</span> idx &lt; n_;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>skip_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Next delegate implementation for skip operators</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Iterator for the sequence type.</span></div><div class="line">        <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Bean containing info to share among delegates</span></div><div class="line">        <span class="keyword">struct </span>skip_info {</div><div class="line">            Seq seq_;               <span class="comment">// Sequence to skip elements from</span></div><div class="line">            iterator_type iend_;    <span class="comment">// Iterator pointing at end of sequence</span></div><div class="line">            Pred pred_;             <span class="comment">// Predicate to satisfy to skip elements</span></div><div class="line"></div><div class="line">            skip_info(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  iend_(std::end(seq_)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            skip_info(<span class="keyword">const</span> skip_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            skip_info&amp; operator=(<span class="keyword">const</span> skip_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> skip_info_sp = std::shared_ptr&lt;skip_info&gt;;</div><div class="line"></div><div class="line">        skip_info_sp spinfo_;       <span class="comment">// Pointer to shared info</span></div><div class="line">        iterator_type icur_;        <span class="comment">// Iterator pointing at current element</span></div><div class="line">        <span class="keywordtype">bool</span> init_called_ = <span class="keyword">false</span>;  <span class="comment">// Whether icur_ has been initialized</span></div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> init() {</div><div class="line">            icur_ = std::begin(spinfo_-&gt;seq_);</div><div class="line">            std::size_t n = 0;</div><div class="line">            <span class="keywordflow">while</span> (icur_ != spinfo_-&gt;iend_ &amp;&amp; spinfo_-&gt;pred_(*icur_, n++)) {</div><div class="line">                ++icur_;</div><div class="line">            }</div><div class="line">            init_called_ = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">            : spinfo_(std::make_shared&lt;skip_info&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                  std::forward&lt;Pred&gt;(pred))) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> {</div><div class="line">            <span class="comment">// Init starting point on first call</span></div><div class="line">            <span class="keywordflow">if</span> (!init_called_) {</div><div class="line">                init();</div><div class="line">            }</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (icur_ != spinfo_-&gt;iend_) {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a> robj = *icur_;</div><div class="line">                pobj = std::addressof(robj);</div><div class="line">                ++icur_;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Pred pred_;     <span class="comment">// Predicate to satisfy to skip.</span></div><div class="line">    std::size_t n_; <span class="comment">// How many items to skip, if known (otherwise -1).</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    skip_impl(Pred&amp;&amp; pred, std::size_t n)</div><div class="line">        : pred_(std::forward&lt;Pred&gt;(pred)),</div><div class="line">          n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;::size_delegate siz;</div><div class="line">        <span class="keywordflow">if</span> (n_ != static_cast&lt;std::size_t&gt;(-1)) {</div><div class="line">            <span class="keyword">auto</span> seq_siz = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq);</div><div class="line">            <span class="keywordflow">if</span> (seq_siz != <span class="keyword">nullptr</span>) {</div><div class="line">                <span class="keyword">const</span> std::size_t seq_size = seq_siz();</div><div class="line">                <span class="keyword">const</span> std::size_t size = seq_size &gt; n_ ? seq_size - n_ : 0;</div><div class="line">                siz = [size]() -&gt; std::size_t { <span class="keywordflow">return</span> size; };</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;(next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                                               std::forward&lt;Pred&gt;(pred_)),</div><div class="line">                                                                siz);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</div><div class="line"><span class="keyword">class </span>sum_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> F&amp; num_f_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> sum_impl(<span class="keyword">const</span> F&amp; num_f)</div><div class="line">        : num_f_(num_f) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; <span class="keyword">typename</span> std::decay&lt;decltype(num_f_(*std::begin(seq)))&gt;::type {</div><div class="line">        <span class="keyword">auto</span> it = std::begin(seq);</div><div class="line">        <span class="keyword">auto</span> end = std::end(seq);</div><div class="line">        <span class="keywordflow">if</span> (it == end) {</div><div class="line">            <a class="code" href="exception_8h.html#a165eac6c80ba18c52c2b43b70de4d810">throw_linq_empty_sequence</a>();</div><div class="line">        }</div><div class="line">        <span class="keyword">auto</span> total = num_f_(*it);</div><div class="line">        <span class="keywordflow">for</span> (++it; it != end; ++it) {</div><div class="line">            total += num_f_(*it);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> total;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>take_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Next delegate implementation for take operators</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Iterator for the sequence type.</span></div><div class="line">        <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Bean containing info to share among delegates</span></div><div class="line">        <span class="keyword">struct </span>take_info {</div><div class="line">            Seq seq_;               <span class="comment">// Sequence to take elements from</span></div><div class="line">            iterator_type iend_;    <span class="comment">// Iterator pointing at end of sequence</span></div><div class="line">            Pred pred_;             <span class="comment">// Predicate to satisfy to take elements</span></div><div class="line"></div><div class="line">            take_info(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  iend_(std::end(seq_)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            take_info(<span class="keyword">const</span> take_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            take_info&amp; operator=(<span class="keyword">const</span> take_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> take_info_sp = std::shared_ptr&lt;take_info&gt;;</div><div class="line"></div><div class="line">        take_info_sp spinfo_;       <span class="comment">// Pointer to shared info</span></div><div class="line">        iterator_type icur_;        <span class="comment">// Iterator pointing at current element</span></div><div class="line">        std::size_t n_ = 0;         <span class="comment">// Index of current element</span></div><div class="line">        <span class="keywordtype">bool</span> done_ = <span class="keyword">false</span>;         <span class="comment">// Whether we&#39;re done taking elements</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">            : spinfo_(std::make_shared&lt;take_info&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                  std::forward&lt;Pred&gt;(pred))),</div><div class="line">              icur_(std::begin(spinfo_-&gt;seq_)) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (!done_) {</div><div class="line">                <span class="keywordflow">if</span> (icur_ != spinfo_-&gt;iend_ &amp;&amp; spinfo_-&gt;pred_(*icur_, n_++)) {</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a> robj = *icur_;</div><div class="line">                    pobj = std::addressof(robj);</div><div class="line">                    ++icur_;</div><div class="line">                } <span class="keywordflow">else</span> {</div><div class="line">                    done_ = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Pred pred_;     <span class="comment">// Predicate to satisfy to skip.</span></div><div class="line">    std::size_t n_; <span class="comment">// How many items to take, if known (otherwise -1).</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    take_impl(Pred&amp;&amp; pred, std::size_t n)</div><div class="line">        : pred_(std::forward&lt;Pred&gt;(pred)),</div><div class="line">          n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;::size_delegate siz;</div><div class="line">        <span class="keywordflow">if</span> (n_ != static_cast&lt;std::size_t&gt;(-1)) {</div><div class="line">            <span class="keyword">auto</span> seq_siz = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq);</div><div class="line">            <span class="keywordflow">if</span> (seq_siz != <span class="keyword">nullptr</span>) {</div><div class="line">                <span class="keyword">const</span> std::size_t size = <a class="code" href="group__linq__op__min.html#gaa01a358923d77a5f0f80b89826454df2">std::min</a>(n_, seq_siz());</div><div class="line">                siz = [size]() -&gt; std::size_t { <span class="keywordflow">return</span> size; };</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;(next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                                               std::forward&lt;Pred&gt;(pred_)),</div><div class="line">                                                                siz);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</div><div class="line"><span class="keyword">class </span>to_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; Container {</div><div class="line">        <span class="keywordflow">return</span> Container(std::begin(std::forward&lt;Seq&gt;(seq)), std::end(std::forward&lt;Seq&gt;(seq)));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>to_vector_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; std::vector&lt;typename seq_traits&lt;Seq&gt;::raw_value_type&gt; {</div><div class="line">        std::vector&lt;typename seq_traits&lt;Seq&gt;::raw_value_type&gt; v;</div><div class="line">        <a class="code" href="sequence__util_8h.html#af58b81e31f744263498f75fcfeac3735">try_reserve</a>(v, seq);</div><div class="line">        v.insert(v.end(), std::begin(std::forward&lt;Seq&gt;(seq)), std::end(std::forward&lt;Seq&gt;(seq)));</div><div class="line">        <span class="keywordflow">return</span> v;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> KeySelector&gt;</div><div class="line"><span class="keyword">class </span>to_associative_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> KeySelector&amp; key_sel_;    <span class="comment">// Selector to fetch keys for sequence elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> to_associative_impl_1(<span class="keyword">const</span> KeySelector&amp; key_sel)</div><div class="line">        : key_sel_(key_sel) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; Container {</div><div class="line">        Container c;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; elem : seq) {</div><div class="line">            <span class="keyword">auto</span> key = key_sel_(elem);</div><div class="line">            <span class="keyword">auto</span> emplace_res = c.emplace(key, elem);</div><div class="line">            <span class="keywordflow">if</span> (!emplace_res.second) {</div><div class="line">                emplace_res.first-&gt;second = elem;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> c;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> KeySelector, <span class="keyword">typename</span> ElementSelector&gt;</div><div class="line"><span class="keyword">class </span>to_associative_impl_2</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> KeySelector&amp; key_sel_;        <span class="comment">// Selector to fetch keys for sequence elements.</span></div><div class="line">    <span class="keyword">const</span> ElementSelector&amp; elem_sel_;   <span class="comment">// Selector to fetch values for sequence elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    to_associative_impl_2(<span class="keyword">const</span> KeySelector&amp; key_sel, <span class="keyword">const</span> ElementSelector&amp; elem_sel)</div><div class="line">        : key_sel_(key_sel), elem_sel_(elem_sel) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) -&gt; Container {</div><div class="line">        Container c;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; elem : seq) {</div><div class="line">            <span class="keyword">auto</span> key = key_sel_(elem);</div><div class="line">            <span class="keyword">auto</span> mapped = elem_sel_(elem);</div><div class="line">            <span class="keyword">auto</span> emplace_res = c.emplace(key, mapped);</div><div class="line">            <span class="keywordflow">if</span> (!emplace_res.second) {</div><div class="line">                emplace_res.first-&gt;second = mapped;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> c;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeySelector&gt;</div><div class="line"><span class="keyword">class </span>to_map_impl_1</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> KeySelector&amp; key_sel_;    <span class="comment">// Selector to fetch keys for sequence elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> to_map_impl_1(<span class="keyword">const</span> KeySelector&amp; key_sel)</div><div class="line">        : key_sel_(key_sel) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; std::map&lt;<span class="keyword">typename</span> std::decay&lt;decltype(key_sel_(*std::begin(seq)))&gt;::type,</div><div class="line">                    <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>&gt;</div><div class="line">    {</div><div class="line">        std::map&lt;<span class="keyword">typename</span> std::decay&lt;decltype(key_sel_(*std::begin(seq)))&gt;::type,</div><div class="line">                 <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_traits&lt;Seq&gt;::raw_value_type</a>&gt; m;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; elem : seq) {</div><div class="line">            <span class="keyword">auto</span> key = key_sel_(elem);</div><div class="line">            <span class="keyword">auto</span> emplace_res = m.emplace(key, elem);</div><div class="line">            <span class="keywordflow">if</span> (!emplace_res.second) {</div><div class="line">                emplace_res.first-&gt;second = elem;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> m;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> KeySelector, <span class="keyword">typename</span> ElementSelector&gt;</div><div class="line"><span class="keyword">class </span>to_map_impl_2</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> KeySelector&amp; key_sel_;        <span class="comment">// Selector to fetch keys for sequence elements.</span></div><div class="line">    <span class="keyword">const</span> ElementSelector&amp; elem_sel_;   <span class="comment">// Selector to fetch values for sequence elements.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    to_map_impl_2(<span class="keyword">const</span> KeySelector&amp; key_sel, <span class="keyword">const</span> ElementSelector&amp; elem_sel)</div><div class="line">        : key_sel_(key_sel), elem_sel_(elem_sel) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; std::map&lt;<span class="keyword">typename</span> std::decay&lt;decltype(key_sel_(*std::begin(seq)))&gt;::type,</div><div class="line">                    <span class="keyword">typename</span> std::decay&lt;decltype(elem_sel_(*std::begin(seq)))&gt;::type&gt;</div><div class="line">    {</div><div class="line">        std::map&lt;<span class="keyword">typename</span> std::decay&lt;decltype(key_sel_(*std::begin(seq)))&gt;::type,</div><div class="line">                 <span class="keyword">typename</span> std::decay&lt;decltype(elem_sel_(*std::begin(seq)))&gt;::type&gt; m;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; elem : seq) {</div><div class="line">            <span class="keyword">auto</span> key = key_sel_(elem);</div><div class="line">            <span class="keyword">auto</span> mapped = elem_sel_(elem);</div><div class="line">            <span class="keyword">auto</span> emplace_res = m.emplace(key, mapped);</div><div class="line">            <span class="keywordflow">if</span> (!emplace_res.second) {</div><div class="line">                emplace_res.first-&gt;second = mapped;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> m;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq2, <span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>union_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate that filters duplicate elements</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// Type of element returned by this next delegate. The elements will be const</span></div><div class="line">        <span class="comment">// if at least one sequence is const.</span></div><div class="line">        <span class="keyword">using</span> enum_type     = <span class="keyword">typename</span> std::conditional&lt;std::is_const&lt;typename seq_traits&lt;Seq1&gt;::value_type&gt;::value ||</div><div class="line">                                                        std::is_const&lt;typename seq_traits&lt;Seq2&gt;::value_type&gt;::value,</div><div class="line">                                                        <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#aa574bb61aefed9bf9336a7c59c4b9ba4">seq_traits&lt;Seq1&gt;::const_value_type</a>,</div><div class="line">                                                        <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#ab63386b3554c084783a8bd6b8f2a744d">seq_traits&lt;Seq1&gt;::value_type</a>&gt;::type;</div><div class="line">        <span class="keyword">using</span> enum_ptr_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_element_traits&lt;enum_type&gt;::pointer</a>;</div><div class="line">        <span class="keyword">using</span> enum_ref_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_element_traits&lt;enum_type&gt;::reference</a>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Type of iterator for the sequences</span></div><div class="line">        <span class="keyword">using</span> first_iterator_type   = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq1&gt;::iterator_type</a>;</div><div class="line">        <span class="keyword">using</span> second_iterator_type  = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq2&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Set storing pointers to seen elements</span></div><div class="line">        <span class="keyword">using</span> seen_elements_set     = std::set&lt;enum_ptr_type, deref_cmp&lt;proxy_cmp&lt;Pred&gt;&gt;&gt;;</div><div class="line"></div><div class="line">        <span class="comment">// Info used to produce distinct elements. Shared among delegates.</span></div><div class="line">        <span class="keyword">class </span>union_info</div><div class="line">        {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            Seq1 seq1_;                     <span class="comment">// First sequence being iterated</span></div><div class="line">            first_iterator_type iend1_;     <span class="comment">// Iterator pointing at end of first sequence</span></div><div class="line">            Seq2 seq2_;                     <span class="comment">// Second sequence being iterated</span></div><div class="line">            second_iterator_type iend2_;    <span class="comment">// Iterator pointing at end of second sequence</span></div><div class="line">            Pred pred_;                     <span class="comment">// Predicate ordering the elements</span></div><div class="line"></div><div class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</div><div class="line">            <span class="keyword">auto</span> get_next_in_seq(It&amp; icur, <span class="keyword">const</span> It&amp; iend, seen_elements_set&amp; seen) -&gt; enum_ptr_type {</div><div class="line">                enum_ptr_type pobj = <span class="keyword">nullptr</span>;</div><div class="line">                <span class="keywordflow">for</span> (; pobj == <span class="keyword">nullptr</span> &amp;&amp; icur != iend; ++icur) {</div><div class="line">                    enum_ref_type robjtmp = *icur;</div><div class="line">                    <span class="keyword">auto</span> pobjtmp = std::addressof(robjtmp);</div><div class="line">                    <span class="keywordflow">if</span> (seen.emplace(pobjtmp).second) {</div><div class="line">                        <span class="comment">// Not seen yet, return this element.</span></div><div class="line">                        pobj = pobjtmp;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> pobj;</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            union_info(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">                : seq1_(std::forward&lt;Seq1&gt;(seq1)),</div><div class="line">                  iend1_(std::end(seq1_)),</div><div class="line">                  seq2_(std::forward&lt;Seq2&gt;(seq2)),</div><div class="line">                  iend2_(std::end(seq2_)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            union_info(<span class="keyword">const</span> union_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            union_info&amp; operator=(<span class="keyword">const</span> union_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            first_iterator_type first_begin() {</div><div class="line">                <span class="keywordflow">return</span> std::begin(seq1_);</div><div class="line">            }</div><div class="line">            second_iterator_type second_begin() {</div><div class="line">                <span class="keywordflow">return</span> std::begin(seq2_);</div><div class="line">            }</div><div class="line">            seen_elements_set init_seen_elements() {</div><div class="line">                <span class="keywordflow">return</span> seen_elements_set(deref_cmp&lt;proxy_cmp&lt;Pred&gt;&gt;(proxy_cmp&lt;Pred&gt;(pred_)));</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Returns next distinct element in either sequence or nullptr when done</span></div><div class="line">            <span class="keyword">auto</span> get_next(first_iterator_type&amp; icur1, second_iterator_type&amp; icur2, seen_elements_set&amp; seen) -&gt; enum_ptr_type {</div><div class="line">                <span class="comment">// First look for an element in first sequence</span></div><div class="line">                enum_ptr_type pobj = get_next_in_seq(icur1, iend1_, seen);</div><div class="line"></div><div class="line">                <span class="comment">// If we did not find an element in first sequence, try in second sequence</span></div><div class="line">                <span class="keywordflow">if</span> (pobj == <span class="keyword">nullptr</span>) {</div><div class="line">                    pobj = get_next_in_seq(icur2, iend2_, seen);</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span> pobj;</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> union_info_sp = std::shared_ptr&lt;union_info&gt;;</div><div class="line"></div><div class="line">        union_info_sp spinfo_;          <span class="comment">// Shared info</span></div><div class="line">        first_iterator_type icur1_;     <span class="comment">// Iterator pointing at current element in first sequence</span></div><div class="line">        second_iterator_type icur2_;    <span class="comment">// Iterator pointing at current element in second sequence</span></div><div class="line">        seen_elements_set seen_;        <span class="comment">// Set of seen elements</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">            : spinfo_(std::make_shared&lt;union_info&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                                                   std::forward&lt;Seq2&gt;(seq2),</div><div class="line">                                                   std::forward&lt;Pred&gt;(pred))),</div><div class="line">              icur1_(spinfo_-&gt;first_begin()),</div><div class="line">              icur2_(spinfo_-&gt;second_begin()),</div><div class="line">              seen_(spinfo_-&gt;init_seen_elements()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; decltype(spinfo_-&gt;get_next(icur1_, icur2_, seen_)) {</div><div class="line">            <span class="keywordflow">return</span> spinfo_-&gt;get_next(icur1_, icur2_, seen_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Seq2 seq2_;     <span class="comment">// Second sequence to union.</span></div><div class="line">    Pred pred_;     <span class="comment">// Predicate used to compare elements</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> union_impl(Seq2&amp;&amp; seq2, Pred&amp;&amp; pred)</div><div class="line">        : seq2_(std::forward&lt;Seq2&gt;(seq2)),</div><div class="line">          pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    union_impl(<span class="keyword">const</span> union_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    union_impl(union_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    union_impl&amp; operator=(<span class="keyword">const</span> union_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    union_impl&amp; operator=(union_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq1&amp;&amp; seq1)</div><div class="line">        -&gt; enumerable&lt;typename next_impl&lt;Seq1&gt;::enum_type&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq1&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                               std::forward&lt;Seq2&gt;(seq2_),</div><div class="line">                               std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Pred&gt;</div><div class="line"><span class="keyword">class </span>where_impl</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate for where/where_with_index operators.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Iterator for the sequence.</span></div><div class="line">        <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Bean storing info shared among delegates.</span></div><div class="line">        <span class="keyword">struct </span>where_info {</div><div class="line">            Seq seq_;               <span class="comment">// Sequence being iterated.</span></div><div class="line">            iterator_type iend_;    <span class="comment">// Iterator pointing at end of seq_</span></div><div class="line">            Pred pred_;             <span class="comment">// Predicate to satisfy</span></div><div class="line"></div><div class="line">            where_info(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  iend_(std::end(seq_)),</div><div class="line">                  pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            where_info(<span class="keyword">const</span> where_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            where_info&amp; operator=(<span class="keyword">const</span> where_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> where_info_sp = std::shared_ptr&lt;where_info&gt;;</div><div class="line"></div><div class="line">        where_info_sp spinfo_;      <span class="comment">// Shared info containing sequence and predicate.</span></div><div class="line">        iterator_type icur_;        <span class="comment">// Pointer at current element.</span></div><div class="line">        std::size_t idx_;           <span class="comment">// Index of current element.</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq&amp;&amp; seq, Pred&amp;&amp; pred)</div><div class="line">            : spinfo_(std::make_shared&lt;where_info&gt;(std::forward&lt;Seq&gt;(seq),</div><div class="line">                                                   std::forward&lt;Pred&gt;(pred))),</div><div class="line">              icur_(std::begin(spinfo_-&gt;seq_)), idx_(0) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">for</span> (; pobj == <span class="keyword">nullptr</span> &amp;&amp; icur_ != spinfo_-&gt;iend_; ++icur_, ++idx_) {</div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq&gt;::reference</a> robjtmp = *icur_;</div><div class="line">                <span class="keyword">auto</span> pobjtmp = std::addressof(robjtmp);</div><div class="line">                <span class="keywordflow">if</span> (spinfo_-&gt;pred_(*pobjtmp, idx_)) {</div><div class="line">                    <span class="comment">// This element satistifies the predicate, return it.</span></div><div class="line">                    pobj = pobjtmp;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Pred pred_;     <span class="comment">// Predicate to satisfy.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> where_impl(Pred&amp;&amp; pred)</div><div class="line">        : pred_(std::forward&lt;Pred&gt;(pred)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    where_impl(<span class="keyword">const</span> where_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    where_impl(where_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    where_impl&amp; operator=(<span class="keyword">const</span> where_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    where_impl&amp; operator=(where_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html#ac745849a61dc02e37399d227e2247790">enumerable&lt;typename seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), std::forward&lt;Pred&gt;(pred_));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq2, <span class="keyword">typename</span> ResultSelector&gt;</div><div class="line"><span class="keyword">class </span>zip_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// Implementation of next delegate for this operator.</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1, <span class="keyword">typename</span> CU, <span class="keyword">typename</span> RU&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="comment">// Iterator types for the sequences.</span></div><div class="line">        <span class="keyword">using</span> first_iterator_type   = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq1&gt;::iterator_type</a>;</div><div class="line">        <span class="keyword">using</span> second_iterator_type  = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">seq_traits&lt;Seq2&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="comment">// Containers storing zipped elements.</span></div><div class="line">        <span class="keyword">using</span> zipped_v              = std::vector&lt;RU&gt;;</div><div class="line">        <span class="keyword">using</span> zipped_l              = std::forward_list&lt;RU&gt;;</div><div class="line">        <span class="keyword">using</span> zipped_l_iterator     = <span class="keyword">typename</span> zipped_l::iterator;</div><div class="line"></div><div class="line">        <span class="comment">// Bean storing info shared among delegates.</span></div><div class="line">        <span class="keyword">struct </span>zip_info {</div><div class="line">            Seq1 seq1_;                     <span class="comment">// First sequence to zip.</span></div><div class="line">            first_iterator_type icur1_;     <span class="comment">// Iterator pointing at current element of seq1_.</span></div><div class="line">            first_iterator_type iend1_;     <span class="comment">// Iterator pointing at end of seq1_.</span></div><div class="line">            Seq2 seq2_;                     <span class="comment">// Second sequence to zip.</span></div><div class="line">            second_iterator_type icur2_;    <span class="comment">// Iterator pointing at current element of seq2_.</span></div><div class="line">            second_iterator_type iend2_;    <span class="comment">// Iterator pointing at end of seq2_.</span></div><div class="line">            ResultSelector result_sel_;     <span class="comment">// Selector producing the results.</span></div><div class="line">            zipped_v vzipped_;              <span class="comment">// Vector of zipped elements.</span></div><div class="line">            zipped_l lzipped_;              <span class="comment">// List of zipped elements.</span></div><div class="line">            zipped_l_iterator llast_;       <span class="comment">// Iterator pointing to last element in lzipped_ (before end()).</span></div><div class="line">            <span class="keywordtype">bool</span> use_vector_;               <span class="comment">// Whether we use lzipped_ (false) or vzipped_ (true).</span></div><div class="line"></div><div class="line">            zip_info(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, ResultSelector&amp;&amp; result_sel,</div><div class="line">                     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classcoveo_1_1enumerable.html#a5a46440b2627e28f2530e9f529703ba8">enumerable&lt;CU&gt;::size_delegate</a>&amp; siz)</div><div class="line">                : seq1_(std::forward&lt;Seq1&gt;(seq1)),</div><div class="line">                  icur1_(std::begin(seq1_)),</div><div class="line">                  iend1_(std::end(seq1_)),</div><div class="line">                  seq2_(std::forward&lt;Seq2&gt;(seq2)),</div><div class="line">                  icur2_(std::begin(seq2_)),</div><div class="line">                  iend2_(std::end(seq2_)),</div><div class="line">                  result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)),</div><div class="line">                  vzipped_(),</div><div class="line">                  lzipped_(),</div><div class="line">                  llast_(lzipped_.before_begin()),</div><div class="line">                  use_vector_(siz != nullptr)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> (siz != <span class="keyword">nullptr</span>) {</div><div class="line">                    vzipped_.reserve(siz());</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Cannot copy/move, stored in a shared_ptr</span></div><div class="line">            zip_info(<span class="keyword">const</span> zip_info&amp;) = <span class="keyword">delete</span>;</div><div class="line">            zip_info&amp; operator=(<span class="keyword">const</span> zip_info&amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> get_next_in_vector(std::size_t&amp; vncur) -&gt; CU* {</div><div class="line">                <span class="keywordflow">while</span> (vzipped_.size() &lt;= vncur &amp;&amp; icur1_ != iend1_ &amp;&amp; icur2_ != iend2_) {</div><div class="line">                    vzipped_.emplace_back(result_sel_(*icur1_, *icur2_));</div><div class="line">                    ++icur1_;</div><div class="line">                    ++icur2_;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> vzipped_.size() &gt; vncur ? std::addressof(vzipped_[vncur++])</div><div class="line">                                               : nullptr;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> get_next_in_list(zipped_l_iterator&amp; licur) -&gt; CU* {</div><div class="line">                <span class="keywordflow">while</span> (licur == llast_ &amp;&amp; icur1_ != iend1_ &amp;&amp; icur2_ != iend2_) {</div><div class="line">                    llast_ = lzipped_.emplace_after(llast_, result_sel_(*icur1_, *icur2_));</div><div class="line">                    ++icur1_;</div><div class="line">                    ++icur2_;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">return</span> licur != llast_ ? std::addressof(*++licur)</div><div class="line">                                       : nullptr;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> get_next(std::size_t&amp; vncur, zipped_l_iterator&amp; licur) -&gt; CU* {</div><div class="line">                <span class="keywordflow">return</span> use_vector_ ? get_next_in_vector(vncur)</div><div class="line">                                   : get_next_in_list(licur);</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> zip_info_sp = std::shared_ptr&lt;zip_info&gt;;</div><div class="line"></div><div class="line">        zip_info_sp spinfo_;            <span class="comment">// Bean containing shared info.</span></div><div class="line">        std::size_t vncur_;             <span class="comment">// Index of current element (if in vector).</span></div><div class="line">        zipped_l_iterator licur_;       <span class="comment">// Iterator pointing at current element (if in list).</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        next_impl(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2, ResultSelector&amp;&amp; result_sel,</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classcoveo_1_1enumerable.html#a5a46440b2627e28f2530e9f529703ba8">enumerable&lt;CU&gt;::size_delegate</a>&amp; siz)</div><div class="line">            : spinfo_(std::make_shared&lt;zip_info&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                                                 std::forward&lt;Seq2&gt;(seq2),</div><div class="line">                                                 std::forward&lt;ResultSelector&gt;(result_sel),</div><div class="line">                                                 siz)),</div><div class="line">              vncur_(0),</div><div class="line">              licur_(spinfo_-&gt;lzipped_.before_begin()) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; CU* {</div><div class="line">            <span class="keywordflow">return</span> spinfo_-&gt;get_next(vncur_, licur_);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Seq2 seq2_;                     <span class="comment">// Second sequence to zip.</span></div><div class="line">    ResultSelector result_sel_;     <span class="comment">// Selector producing the results.</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    zip_impl(Seq2&amp;&amp; seq2, ResultSelector&amp;&amp; result_sel)</div><div class="line">        : seq2_(std::forward&lt;Seq2&gt;(seq2)),</div><div class="line">          result_sel_(std::forward&lt;ResultSelector&gt;(result_sel)) { }</div><div class="line"></div><div class="line">    <span class="comment">// Movable but not copyable</span></div><div class="line">    zip_impl(<span class="keyword">const</span> zip_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    zip_impl(zip_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">    zip_impl&amp; operator=(<span class="keyword">const</span> zip_impl&amp;) = <span class="keyword">delete</span>;</div><div class="line">    zip_impl&amp; operator=(zip_impl&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq1,</div><div class="line">             <span class="keyword">typename</span> _SelectorRes = decltype(std::declval&lt;ResultSelector&gt;()(std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq1&gt;::reference</a>&gt;(),</div><div class="line">                                                                             std::declval&lt;<span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">seq_traits&lt;Seq2&gt;::reference</a>&gt;())),</div><div class="line">             <span class="keyword">typename</span> _CU = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#aa574bb61aefed9bf9336a7c59c4b9ba4">seq_element_traits&lt;_SelectorRes&gt;::const_value_type</a>,</div><div class="line">             <span class="keyword">typename</span> _RU = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a7554b1bfb5770f86d4b1d09bb82260e2">seq_element_traits&lt;_SelectorRes&gt;::raw_value_type</a>&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq1&amp;&amp; seq1) -&gt; enumerable&lt;_CU&gt; {</div><div class="line">        <span class="keyword">auto</span> siz1 = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq1);</div><div class="line">        <span class="keyword">auto</span> siz2 = <a class="code" href="sequence__util_8h.html#a3b2f2644800c1371e61c05fc3ad4d58b">try_get_size_delegate</a>(seq2_);</div><div class="line">        <span class="keyword">typename</span> <a class="code" href="classcoveo_1_1enumerable.html#a5a46440b2627e28f2530e9f529703ba8">enumerable&lt;_CU&gt;::size_delegate</a> siz;</div><div class="line">        <span class="keywordflow">if</span> (siz1 != <span class="keyword">nullptr</span> &amp;&amp; siz2 != <span class="keyword">nullptr</span>) {</div><div class="line">            <span class="keyword">const</span> std::size_t min_size = <a class="code" href="group__linq__op__min.html#gaa01a358923d77a5f0f80b89826454df2">std::min</a>(siz1(), siz2());</div><div class="line">            siz = [min_size]() -&gt; std::size_t { <span class="keywordflow">return</span> min_size; };</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> enumerable&lt;_CU&gt;(next_impl&lt;Seq1, _CU, _RU&gt;(std::forward&lt;Seq1&gt;(seq1),</div><div class="line">                                                         std::forward&lt;Seq2&gt;(seq2_),</div><div class="line">                                                         std::forward&lt;ResultSelector&gt;(result_sel_),</div><div class="line">                                                         siz),</div><div class="line">                               siz);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// detail</span></div><div class="line">} <span class="comment">// linq</span></div><div class="line">} <span class="comment">// coveo</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif // COVEO_LINQ_DETAIL_H</span></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 10 2019 20:33:10 for coveo::linq by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
