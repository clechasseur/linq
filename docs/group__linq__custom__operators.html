<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coveo::linq: Implementing custom LINQ operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coveo::linq
   </div>
   <div id="projectbrief">Implementation of .NET-like LINQ operators in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Implementing custom LINQ operators<div class="ingroups"><a class="el" href="group__linq.html">LINQ expressions</a> &raquo; <a class="el" href="group__linq__operators.html">LINQ operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>How to design and implement your own LINQ operators.  
<a href="#details">More...</a></p>
<p>One of the features of the <code>coveo::linq</code> library is that LINQ operators are implemented as <em>function objects</em> to be applied to a sequence, instead of member functions (of <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code> for instance.) This makes it easy to extend the library by implementing new operators.</p>
<p>To make it easy to apply LINQ operators, the library defines, for each operator, a corresponding function that simply returns the <em>function object</em>. Then, <code><a class="el" href="group__linq__chaining.html#gaf38ff23c8bdf9a47b55e516dd378194e" title="Applies LINQ operators and allows chaining.">coveo::linq::operator|()</a></code> is used to <em>apply</em> the LINQ operator to a sequence. What this means internally is that <code><a class="el" href="group__linq__chaining.html#gaf38ff23c8bdf9a47b55e516dd378194e" title="Applies LINQ operators and allows chaining.">operator|()</a></code> calls the operator's function object's <code>operator()()</code> member function, passing it the sequence to apply it to. The operator's function object must then perform its work and return either a new sequence or perhaps a single value (for a terminal operator).</p>
<p>Here is a real-world example of this. Let's say we wanted to implement a new LINQ operator named <code>step</code> that steps through a sequence by specific increments. First, we declare the shell of our function object that implements the operator, along with an <code>operator()()</code> so that the operator can be applied to a sequence:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq) {</div><div class="line">        <span class="comment">// TODO</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note that the sequence's type is not specified in the class template itself - when the operator's function object will be created, we won't know the type of sequence yet. Instead, it is specified as a template argument to <code>operator()()</code> itself. Also note that the function object's constructor must receive all parameters it needs to work (except for the sequence of course). In our case, we receive the number of steps to use for each invocation.</p>
<p>Because our operator must step through elements of the sequence it is applied to, it needs to return a new sequence. Furthermore, that sequence must wrap the source sequence to be able to iterate its elements. One way to do this without implementing complex sequence logic is by using <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code>. This sequence wrapper's only requirement is that we implement a <em>next delegate</em>: a function that, when called, returns a pointer to the next element in the sequence, or <code>nullptr</code> when done. <code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code> is used extensively in the <code>coveo::linq</code> library to implement LINQ operators.</p>
<p>Let's add a skeleton for a next delegate to our example:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl(Seq&amp;&amp; seq, std::site_t n) {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;typename coveo::seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), n_);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Note the use of <code><a class="el" href="structcoveo_1_1seq__traits.html" title="Traits class for a sequence.">coveo::seq_traits</a></code> to produce a sequence of the same type of elements as the source sequence. Along with <code><a class="el" href="structcoveo_1_1seq__element__traits.html" title="Traits class for elements in a sequence.">coveo::seq_element_traits</a></code>, these can be used to simplify detection of sequence types in LINQ operator implementations.</p>
<p><code><a class="el" href="classcoveo_1_1enumerable.html" title="Type-erased sequence wrapper.">coveo::enumerable</a></code>'s implementation will <em>copy</em> the next delegate every time it is needed - in its copy/move constructors / assignment operators, but also when an iterator is fetched. This is done so that the state of the enumeration can be kept in the next delegate and copied as well. Because of this however, objects to be shared among delegates must be kept in shared memory as well - using <code>std::shared_ptr</code> for instance.</p>
<p>Let's add storage for our sequence in our example's next delegate:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">coveo::seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>internals {</div><div class="line">            Seq seq_;</div><div class="line">            iterator_type end_;</div><div class="line">            std::size_t n_;</div><div class="line"></div><div class="line">            internals(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  end_(std::end(seq_)),</div><div class="line">                  n_(n) { }</div><div class="line">            internals(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">            internals&amp; operator=(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> internals_sp = std::shared_ptr&lt;internals&gt;;</div><div class="line"></div><div class="line">        internals_sp spint_;</div><div class="line">        iterator_type it_;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">            : spint_(std::make_shared&lt;internals&gt;(std::forward&lt;Seq&gt;(seq), n)),</div><div class="line">              it_(std::begin(spint_-&gt;seq_)) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() {</div><div class="line">            <span class="comment">// TODO</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;typename coveo::seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), n_);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The <code>internals</code> class is used to keep all data that is to be shared among next delegates, including the sequence we're wrapping. This allows us to avoid copying the sequence for every delegate copy. The <code>internals</code> are kept in a <code>std::shared_ptr</code>.</p>
<p>Also note that we keep an <code>end</code> iterator in the <code>internals</code> object, but we keep another iterator in the next delegate directly. This is the <b>state</b> of the enumeration: the iterator points to the next element we'll be returning. This iterator is initialized at <code>begin</code> initially.</p>
<p>Now, all that is left is to implement the operator logic itself: iterating over the sequence, stepping through elements by a specific increment.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">class </span>step_impl</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">class </span>next_impl</div><div class="line">    {</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">using</span> iterator_type = <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__traits.html#ab6b3a5cd4263ae0168e54fbcae3e9776">coveo::seq_traits&lt;Seq&gt;::iterator_type</a>;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>internals {</div><div class="line">            Seq seq_;</div><div class="line">            iterator_type end_;</div><div class="line">            std::size_t n_;</div><div class="line"></div><div class="line">            internals(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">                : seq_(std::forward&lt;Seq&gt;(seq)),</div><div class="line">                  end_(std::end(seq_)),</div><div class="line">                  n_(n) { }</div><div class="line">            internals(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">            internals&amp; operator=(<span class="keyword">const</span> internals&amp;) = <span class="keyword">delete</span>;</div><div class="line">        };</div><div class="line">        <span class="keyword">using</span> internals_sp = std::shared_ptr&lt;internals&gt;;</div><div class="line"></div><div class="line">        internals_sp spint_;</div><div class="line">        iterator_type it_;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">explicit</span> next_impl(Seq&amp;&amp; seq, std::size_t n)</div><div class="line">            : spint_(std::make_shared&lt;internals&gt;(std::forward&lt;Seq&gt;(seq), n)),</div><div class="line">              it_(std::begin(spint_-&gt;seq_)) { }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> operator()() -&gt; <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">coveo::seq_traits&lt;Seq&gt;::pointer</a> {</div><div class="line">            <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a39315f40fe94e2998b917ae6ac4fe946">coveo::seq_traits&lt;Seq&gt;::pointer</a> pobj = <span class="keyword">nullptr</span>;</div><div class="line">            <span class="keywordflow">if</span> (it_ != spint_-&gt;end_) {</div><div class="line">                <span class="comment">// Return this element.</span></div><div class="line">                <span class="keyword">typename</span> <a class="code" href="structcoveo_1_1seq__element__traits.html#a084e319fd71b5954a2906044d7b795cf">coveo::seq_traits&lt;Seq&gt;::reference</a> robj = *it_;</div><div class="line">                pobj = std::addressof(robj);</div><div class="line"></div><div class="line">                <span class="comment">// Move to next element by stepping as appropriate.</span></div><div class="line">                <span class="keywordflow">for</span> (std::size_t i = 0; it_ != spint_-&gt;end_ &amp;&amp; i &lt; spint_-&gt;n_; ++i, ++it_) {</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keywordflow">return</span> pobj;</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    std::size_t n_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">explicit</span> step_impl(std::size_t n) : n_(n) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq&gt;</div><div class="line">    <span class="keyword">auto</span> operator()(Seq&amp;&amp; seq)</div><div class="line">        -&gt; <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;typename coveo::seq_traits&lt;Seq&gt;::value_type</a>&gt;</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> next_impl&lt;Seq&gt;(std::forward&lt;Seq&gt;(seq), n_);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div><div class="line"><span class="keyword">auto</span> step(std::size_t n) -&gt; step_impl&lt;&gt; {</div><div class="line">    <span class="keywordflow">return</span> step_impl&lt;&gt;(n);</div><div class="line">}</div></div><!-- fragment --><p>Note that we also added a "helper function" that returns our operator's function object's implementation. This function will be the one used to invoke our LINQ operator:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> NUMS[] = { 42, 23, 66, 11, 7, 67 };</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> seq = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(NUMS)</div><div class="line">         | step(2);</div><div class="line"><span class="comment">// seq == { 42, 66, 7 };</span></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 8 2019 23:19:38 for coveo::linq by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
