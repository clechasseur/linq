<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>coveo::linq: group_by / group_values_by / group_by_and_fold / group_values_by_and_fold</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">coveo::linq
   </div>
   <div id="projectbrief">Implementation of .NET-like LINQ operators in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">group_by / group_values_by / group_by_and_fold / group_values_by_and_fold<div class="ingroups"><a class="el" href="group__linq.html">LINQ expressions</a> &raquo; <a class="el" href="group__linq__operators.html">LINQ operators</a> &raquo; <a class="el" href="group__linq__operators__list.html">List of built-in LINQ operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Groups elements in a sequence according to their keys.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab6619d060bee7e02d929c2f7a3884af4"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector &gt; </td></tr>
<tr class="memitem:gab6619d060bee7e02d929c2f7a3884af4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#gab6619d060bee7e02d929c2f7a3884af4">coveo::linq::group_by</a> (KeySelector &amp;&amp;key_sel) -&gt; detail::group_by_impl&lt; KeySelector, detail::identity&lt;&gt;, detail::pair_of&lt;&gt;, detail::less&lt;&gt;&gt;</td></tr>
<tr class="memdesc:gab6619d060bee7e02d929c2f7a3884af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements in sequence according to their keys.  <a href="group__linq__op__group__by.html#gab6619d060bee7e02d929c2f7a3884af4">More...</a><br /></td></tr>
<tr class="separator:gab6619d060bee7e02d929c2f7a3884af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8c61aee277cd3c9f8c9e28f4ed3652"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector , typename Pred &gt; </td></tr>
<tr class="memitem:ga0a8c61aee277cd3c9f8c9e28f4ed3652"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#ga0a8c61aee277cd3c9f8c9e28f4ed3652">coveo::linq::group_by</a> (KeySelector &amp;&amp;key_sel, Pred &amp;&amp;pred) -&gt; detail::group_by_impl&lt; KeySelector, detail::identity&lt;&gt;, detail::pair_of&lt;&gt;, Pred &gt;</td></tr>
<tr class="memdesc:ga0a8c61aee277cd3c9f8c9e28f4ed3652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements in sequence according to their keys using predicate.  <a href="group__linq__op__group__by.html#ga0a8c61aee277cd3c9f8c9e28f4ed3652">More...</a><br /></td></tr>
<tr class="separator:ga0a8c61aee277cd3c9f8c9e28f4ed3652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga396685efd7c3cfd8833c377fff0bccb0"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector , typename ValueSelector &gt; </td></tr>
<tr class="memitem:ga396685efd7c3cfd8833c377fff0bccb0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#ga396685efd7c3cfd8833c377fff0bccb0">coveo::linq::group_values_by</a> (KeySelector &amp;&amp;key_sel, ValueSelector &amp;&amp;value_sel) -&gt; detail::group_by_impl&lt; KeySelector, ValueSelector, detail::pair_of&lt;&gt;, detail::less&lt;&gt;&gt;</td></tr>
<tr class="memdesc:ga396685efd7c3cfd8833c377fff0bccb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups values in sequence according to their keys.  <a href="group__linq__op__group__by.html#ga396685efd7c3cfd8833c377fff0bccb0">More...</a><br /></td></tr>
<tr class="separator:ga396685efd7c3cfd8833c377fff0bccb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8109f136f13d2ebea9991d957066085"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector , typename ValueSelector , typename Pred &gt; </td></tr>
<tr class="memitem:gab8109f136f13d2ebea9991d957066085"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#gab8109f136f13d2ebea9991d957066085">coveo::linq::group_values_by</a> (KeySelector &amp;&amp;key_sel, ValueSelector &amp;&amp;value_sel, Pred &amp;&amp;pred) -&gt; detail::group_by_impl&lt; KeySelector, ValueSelector, detail::pair_of&lt;&gt;, Pred &gt;</td></tr>
<tr class="memdesc:gab8109f136f13d2ebea9991d957066085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups values in sequence according to their keys using predicate.  <a href="group__linq__op__group__by.html#gab8109f136f13d2ebea9991d957066085">More...</a><br /></td></tr>
<tr class="separator:gab8109f136f13d2ebea9991d957066085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbf727bf03599ee5f98436b4b439f0d"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector , typename ResultSelector &gt; </td></tr>
<tr class="memitem:ga3dbf727bf03599ee5f98436b4b439f0d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#ga3dbf727bf03599ee5f98436b4b439f0d">coveo::linq::group_by_and_fold</a> (KeySelector &amp;&amp;key_sel, ResultSelector &amp;&amp;result_sel) -&gt; detail::group_by_impl&lt; KeySelector, detail::identity&lt;&gt;, ResultSelector, detail::less&lt;&gt;&gt;</td></tr>
<tr class="memdesc:ga3dbf727bf03599ee5f98436b4b439f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements in sequence according to their keys then folds the results.  <a href="group__linq__op__group__by.html#ga3dbf727bf03599ee5f98436b4b439f0d">More...</a><br /></td></tr>
<tr class="separator:ga3dbf727bf03599ee5f98436b4b439f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891e502ed71d960860e68931b84ba69f"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector , typename ResultSelector , typename Pred &gt; </td></tr>
<tr class="memitem:ga891e502ed71d960860e68931b84ba69f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#ga891e502ed71d960860e68931b84ba69f">coveo::linq::group_by_and_fold</a> (KeySelector &amp;&amp;key_sel, ResultSelector &amp;&amp;result_sel, Pred &amp;&amp;pred) -&gt; detail::group_by_impl&lt; KeySelector, detail::identity&lt;&gt;, ResultSelector, Pred &gt;</td></tr>
<tr class="memdesc:ga891e502ed71d960860e68931b84ba69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements in sequence according to their keys using predicate, then folds the results.  <a href="group__linq__op__group__by.html#ga891e502ed71d960860e68931b84ba69f">More...</a><br /></td></tr>
<tr class="separator:ga891e502ed71d960860e68931b84ba69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2a62052fbd268dd9f846b26472fb8b"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector , typename ValueSelector , typename ResultSelector &gt; </td></tr>
<tr class="memitem:ga0e2a62052fbd268dd9f846b26472fb8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#ga0e2a62052fbd268dd9f846b26472fb8b">coveo::linq::group_values_by_and_fold</a> (KeySelector &amp;&amp;key_sel, ValueSelector &amp;&amp;value_sel, ResultSelector &amp;&amp;result_sel) -&gt; detail::group_by_impl&lt; KeySelector, ValueSelector, ResultSelector, detail::less&lt;&gt;&gt;</td></tr>
<tr class="memdesc:ga0e2a62052fbd268dd9f846b26472fb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups values in sequence according to their keys then folds the results.  <a href="group__linq__op__group__by.html#ga0e2a62052fbd268dd9f846b26472fb8b">More...</a><br /></td></tr>
<tr class="separator:ga0e2a62052fbd268dd9f846b26472fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1589867e12b285488233ee06896cb1d"><td class="memTemplParams" colspan="2">template&lt;typename KeySelector , typename ValueSelector , typename ResultSelector , typename Pred &gt; </td></tr>
<tr class="memitem:gab1589867e12b285488233ee06896cb1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__linq__op__group__by.html#gab1589867e12b285488233ee06896cb1d">coveo::linq::group_values_by_and_fold</a> (KeySelector &amp;&amp;key_sel, ValueSelector &amp;&amp;value_sel, ResultSelector &amp;&amp;result_sel, Pred &amp;&amp;pred) -&gt; detail::group_by_impl&lt; KeySelector, ValueSelector, ResultSelector, Pred &gt;</td></tr>
<tr class="memdesc:gab1589867e12b285488233ee06896cb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups values in sequence according to their keys using predicate, then folds the results.  <a href="group__linq__op__group__by.html#gab1589867e12b285488233ee06896cb1d">More...</a><br /></td></tr>
<tr class="separator:gab1589867e12b285488233ee06896cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>group_by</code> operator (and its siblings) group elements in a sequence according to their keys. Keys are extracted from elements using a <em>key selector</em>. Variants of the operator can also extract values from elements using a <em>value selector</em>, or modify the resulting sequence using a <em>result selector</em>.</p>
<p><b>.NET equivalent:</b> GroupBy </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab6619d060bee7e02d929c2f7a3884af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6619d060bee7e02d929c2f7a3884af4">&#9670;&nbsp;</a></span>group_by() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_by </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em></td><td>)</td>
          <td> -&gt; detail::group_by_impl&lt;KeySelector,
                             detail::identity&lt;&gt;,
                             detail::pair_of&lt;&gt;,
                             detail::less&lt;&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em>. Then, creates groups of elements that have a common key. The result is a sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of elements matching that key. The groups are returned in ascending order of key, as determined by <code>operator&lt;()</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> groups = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">            | <a class="code" href="group__linq__op__group__by.html#gab6619d060bee7e02d929c2f7a3884af4">group_by</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; });</div><div class="line"><span class="keyword">auto</span> it = std::begin(groups);</div><div class="line"><span class="keyword">auto</span> group1 = *it++;</div><div class="line"><span class="keyword">auto</span> group2 = *it++;</div><div class="line"><span class="keyword">auto</span> group3 = *it++;</div><div class="line"><span class="comment">// group1.first == 23, group1.second == { { 23, &quot;Hangar&quot; }, { 23, &quot;Jeep&quot; } }</span></div><div class="line"><span class="comment">// group2.first == 42, group2.second == { { 42, &quot;Life&quot; }, { 42, &quot;Universe&quot; } }</span></div><div class="line"><span class="comment">// group3.first == 66, group3.second == { { 66, &quot;Route&quot; } }</span></div><div class="line"><span class="comment">// it == std::end(groups)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of matching elements. </dd></dl>

</div>
</div>
<a id="ga0a8c61aee277cd3c9f8c9e28f4ed3652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a8c61aee277cd3c9f8c9e28f4ed3652">&#9670;&nbsp;</a></span>group_by() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_by </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::group_by_impl&lt;KeySelector,
                             detail::identity&lt;&gt;,
                             detail::pair_of&lt;&gt;,
                             Pred&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em>. Then, creates groups of elements that have a common key. The result is a sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of elements matching that key. The groups are returned in order of key, as determined by the provided predicate. The predicate must provide a strict ordering of the keys, like <code>std::less</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> groups = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">            | <a class="code" href="group__linq__op__group__by.html#gab6619d060bee7e02d929c2f7a3884af4">group_by</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; },</div><div class="line">                       [](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) { <span class="keywordflow">return</span> i &gt; j; });</div><div class="line"><span class="keyword">auto</span> it = std::begin(groups);</div><div class="line"><span class="keyword">auto</span> group1 = *it++;</div><div class="line"><span class="keyword">auto</span> group2 = *it++;</div><div class="line"><span class="keyword">auto</span> group3 = *it++;</div><div class="line"><span class="comment">// group1.first == 66, group1.second == { { 66, &quot;Route&quot; } }</span></div><div class="line"><span class="comment">// group2.first == 42, group2.second == { { 42, &quot;Life&quot; }, { 42, &quot;Universe&quot; } }</span></div><div class="line"><span class="comment">// group3.first == 23, group3.second == { { 23, &quot;Hangar&quot; }, { 23, &quot;Jeep&quot; } }</span></div><div class="line"><span class="comment">// it == std::end(groups)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate used to compare the keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of matching elements. </dd></dl>

</div>
</div>
<a id="ga396685efd7c3cfd8833c377fff0bccb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga396685efd7c3cfd8833c377fff0bccb0">&#9670;&nbsp;</a></span>group_values_by() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector , typename ValueSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_values_by </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>value_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::group_by_impl&lt;KeySelector,
                             ValueSelector,
                             detail::pair_of&lt;&gt;,
                             detail::less&lt;&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em> and a value using the provided <em>value selector</em>. Then, creates groups of values that have a common key. The result is a sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of values matching that key. The groups are returned in ascending order of key, as determined by <code>operator&lt;()</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> groups = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">            | <a class="code" href="group__linq__op__group__by.html#ga396685efd7c3cfd8833c377fff0bccb0">group_values_by</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; },</div><div class="line">                              [](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.second; });</div><div class="line"><span class="keyword">auto</span> it = std::begin(groups);</div><div class="line"><span class="keyword">auto</span> group1 = *it++;</div><div class="line"><span class="keyword">auto</span> group2 = *it++;</div><div class="line"><span class="keyword">auto</span> group3 = *it++;</div><div class="line"><span class="comment">// group1.first == 23, group1.second == { &quot;Hangar&quot;, &quot;Jeep&quot; }</span></div><div class="line"><span class="comment">// group2.first == 42, group2.second == { &quot;Life&quot;, &quot;Universe&quot; }</span></div><div class="line"><span class="comment">// group3.first == 66, group3.second == { &quot;Route&quot; }</span></div><div class="line"><span class="comment">// it == std::end(groups)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
    <tr><td class="paramname">value_sel</td><td>Value selector, used to extract a value for a sequence element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of matching values. </dd></dl>

</div>
</div>
<a id="gab8109f136f13d2ebea9991d957066085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8109f136f13d2ebea9991d957066085">&#9670;&nbsp;</a></span>group_values_by() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector , typename ValueSelector , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_values_by </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>value_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::group_by_impl&lt;KeySelector,
                             ValueSelector,
                             detail::pair_of&lt;&gt;,
                             Pred&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em> and a value using the provided <em>value selector</em>. Then, creates groups of values that have a common key. The result is a sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of values matching that key. The groups are returned in order of key, as determined by the provided predicate. The predicate must provide a strict ordering of the keys, like <code>std::less</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> groups = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">            | <a class="code" href="group__linq__op__group__by.html#ga396685efd7c3cfd8833c377fff0bccb0">group_values_by</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; },</div><div class="line">                              [](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.second; },</div><div class="line">                              [](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) { <span class="keywordflow">return</span> i &gt; j; });</div><div class="line"><span class="keyword">auto</span> it = std::begin(groups);</div><div class="line"><span class="keyword">auto</span> group1 = *it++;</div><div class="line"><span class="keyword">auto</span> group2 = *it++;</div><div class="line"><span class="keyword">auto</span> group3 = *it++;</div><div class="line"><span class="comment">// group1.first == 66, group1.second == { &quot;Route&quot; }</span></div><div class="line"><span class="comment">// group2.first == 42, group2.second == { &quot;Life&quot;, &quot;Universe&quot; }</span></div><div class="line"><span class="comment">// group3.first == 23, group3.second == { &quot;Hangar&quot;, &quot;Jeep&quot; }</span></div><div class="line"><span class="comment">// it == std::end(groups)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
    <tr><td class="paramname">value_sel</td><td>Value selector, used to extract a value for a sequence element. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate used to compare the keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of <code>pair</code>s whose <code>first</code> element is a key and whose <code>second</code> element is a sequence of matching values. </dd></dl>

</div>
</div>
<a id="ga3dbf727bf03599ee5f98436b4b439f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dbf727bf03599ee5f98436b4b439f0d">&#9670;&nbsp;</a></span>group_by_and_fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector , typename ResultSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_by_and_fold </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>result_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::group_by_impl&lt;KeySelector,
                             detail::identity&lt;&gt;,
                             ResultSelector,
                             detail::less&lt;&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em>. Then, creates groups of elements that have a common key and uses the provided <em>result selector</em> to convert the groups. The result selector is called with two arguments: a key, and a sequence of elements matching that key. The final result is a sequence of the values returned by the result selector. The result selector is called in ascending order of key, as determined by <code>operator&lt;()</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> res = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">         | <a class="code" href="group__linq__op__group__by.html#ga3dbf727bf03599ee5f98436b4b439f0d">group_by_and_fold</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; },</div><div class="line">                             [](<span class="keywordtype">int</span> k, <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;const std::pair&lt;int, std::string&gt;</a>&gt; e) { k + <span class="keywordflow">return</span> e.size(); });</div><div class="line"><span class="comment">// res == { 25, 44, 67 }</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
    <tr><td class="paramname">result_sel</td><td>Result selector, used to fold groups into final results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of values returned by <code>result_sel</code>. </dd></dl>

</div>
</div>
<a id="ga891e502ed71d960860e68931b84ba69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga891e502ed71d960860e68931b84ba69f">&#9670;&nbsp;</a></span>group_by_and_fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector , typename ResultSelector , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_by_and_fold </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>result_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::group_by_impl&lt;KeySelector,
                             detail::identity&lt;&gt;,
                             ResultSelector,
                             Pred&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em>. Then, creates groups of elements that have a common key and uses the provided <em>result selector</em> to convert the groups. The result selector is called with two arguments: a key, and a sequence of elements matching that key. The final result is a sequence of the values returned by the result selector. The result selector is called in order of key, as determined by the provided predicate. The predicate must provide a strict ordering of the keys, like <code>std::less</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> res = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">         | <a class="code" href="group__linq__op__group__by.html#ga3dbf727bf03599ee5f98436b4b439f0d">group_by_and_fold</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; },</div><div class="line">                             [](<span class="keywordtype">int</span> k, <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;const std::pair&lt;int, std::string&gt;</a>&gt; e) { k + <span class="keywordflow">return</span> e.size(); },</div><div class="line">                             [](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) { <span class="keywordflow">return</span> i &gt; j; });</div><div class="line"><span class="comment">// res == { 67, 44, 25 }</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
    <tr><td class="paramname">result_sel</td><td>Result selector, used to fold groups into final results. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate used to compare the keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of values returned by <code>result_sel</code>. </dd></dl>

</div>
</div>
<a id="ga0e2a62052fbd268dd9f846b26472fb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e2a62052fbd268dd9f846b26472fb8b">&#9670;&nbsp;</a></span>group_values_by_and_fold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector , typename ValueSelector , typename ResultSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_values_by_and_fold </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>value_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>result_sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::group_by_impl&lt;KeySelector,
                             ValueSelector,
                             ResultSelector,
                             detail::less&lt;&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em> and a value using the provided <em>value selector</em>. Then, creates groups of values that have a common key and uses the provided <em>result selector</em> to convert the groups. The result selector is called with two arguments: a key, and a sequence of values matching that key. The final result is a sequence of the values returned by the result selector. The result selector is called in ascending order of key, as determined by <code>operator&lt;()</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> res = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">         | <a class="code" href="group__linq__op__group__by.html#ga0e2a62052fbd268dd9f846b26472fb8b">group_values_by_and_fold</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; },</div><div class="line">                                    [](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.second; },</div><div class="line">                                    [](<span class="keywordtype">int</span> k, <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;const std::string&gt;</a> e) { k + <span class="keywordflow">return</span> e.begin()-&gt;size(); });</div><div class="line"><span class="comment">// res == { 29, 46, 71 }</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
    <tr><td class="paramname">value_sel</td><td>Value selector, used to extract a value for a sequence element. </td></tr>
    <tr><td class="paramname">result_sel</td><td>Result selector, used to fold groups into final results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of values returned by <code>result_sel</code>. </dd></dl>

</div>
</div>
<a id="gab1589867e12b285488233ee06896cb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1589867e12b285488233ee06896cb1d">&#9670;&nbsp;</a></span>group_values_by_and_fold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeySelector , typename ValueSelector , typename ResultSelector , typename Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto coveo::linq::group_values_by_and_fold </td>
          <td>(</td>
          <td class="paramtype">KeySelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>key_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>value_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>result_sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::group_by_impl&lt;KeySelector,
                             ValueSelector,
                             ResultSelector,
                             Pred&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the input sequence and, for each element, fetches a key using the provided <em>key selector</em> and a value using the provided <em>value selector</em>. Then, creates groups of values that have a common key and uses the provided <em>result selector</em> to convert the groups. The result selector is called with two arguments: a key, and a sequence of values matching that key. The final result is a sequence of the values returned by the result selector. The result selector is called in order of key, as determined by the provided predicate. The predicate must provide a strict ordering of the keys, like <code>std::less</code>.</p>
<p>Use like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::pair&lt;int, std::string&gt;&gt; DATA = {</div><div class="line">    { 42, <span class="stringliteral">&quot;Life&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Hangar&quot;</span> },</div><div class="line">    { 42, <span class="stringliteral">&quot;Universe&quot;</span> },</div><div class="line">    { 66, <span class="stringliteral">&quot;Route&quot;</span> },</div><div class="line">    { 23, <span class="stringliteral">&quot;Jeep&quot;</span> },</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span>coveo::linq;</div><div class="line"><span class="keyword">auto</span> res = <a class="code" href="group__linq__entry__points.html#ga974e5ae2b7dec6aecc4be4b58546f6e2">from</a>(DATA)</div><div class="line">         | <a class="code" href="group__linq__op__group__by.html#ga0e2a62052fbd268dd9f846b26472fb8b">group_values_by_and_fold</a>([](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.first; },</div><div class="line">                                    [](std::pair&lt;int, std::string&gt; p) { <span class="keywordflow">return</span> p.second; },</div><div class="line">                                    [](<span class="keywordtype">int</span> k, <a class="code" href="classcoveo_1_1enumerable.html">coveo::enumerable&lt;const std::string&gt;</a> e) { k + <span class="keywordflow">return</span> e.begin()-&gt;size(); },</div><div class="line">                                    [](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) { <span class="keywordflow">return</span> i &gt; j; });</div><div class="line"><span class="comment">// res == { 71, 46, 29 }</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_sel</td><td>Key selector, used to extract a key for a sequence element. </td></tr>
    <tr><td class="paramname">value_sel</td><td>Value selector, used to extract a value for a sequence element. </td></tr>
    <tr><td class="paramname">result_sel</td><td>Result selector, used to fold groups into final results. </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate used to compare the keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(Once applied) Sequence of values returned by <code>result_sel</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 10 2019 20:33:10 for coveo::linq by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
